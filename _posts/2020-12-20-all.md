---
title: 八股文合集
author: yousabla
date: 2020-12-20 22:54:00 +0800
categories: [八股文]
tags: [八股文]
pin: true
---

# Java基础

集合类主要分为三种：Set（集合），List（列表），Map（映射）

集合分为：Collection和Map，其中List、Set是Collection的子类。

![image-20200918193945338](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200918193945338.png)

## List：

可重复，通过索引取出和加入数据，顺序与插入顺序一致，可包含null元素

### ArrayList（非线程安全）：

底层数据结构为Object[]，查询快，通过索引（即数组角标）进行随机访问的时间复杂度为O（1）（内存空间连续且元素类型相同，故支持随机访问），增删慢（删除需要数组的复制，增加除此之外还可能需要数组的扩充）,在数组达到上限时，每次扩充当前长度的50%

### LinkedList（非线程安全）：

底层数据结构为链表，查询慢（只能从头遍历），增删快（内存地址不连续，增删只需更改相关节点的索引）

### Vector（线程安全）：

与ArrayList类似，区别在于：1.Vector内部增加了synchronized关键字，所以它是线程安全的，但也因为如此，他的效率有所下降；2.Vector的数组扩容长度是当前长度的100%，如果集合中数据量较大，可以考虑使用Vector。

## Set：

数据无序且唯一，实现类**皆非线程安全类**，简单解决方案：

```java
Set set = Collections.sysnchronizedSet(Set对象);  
```

集合均可使用该方法加入同步锁。

**如何保证Set内元素唯一(即如何保证HashMap键值为一)?**

将一个key-value对放入HashMap中时，首先根据key的hashCode()返回值决定该Entry的存储位置，如果两个key的hash值相同，那么它们的存储位置相同。如果这个两个key的equals比较返回true。那么新添加的Entry的value会覆盖原来的Entry的value，key不会覆盖，而HashSet中的Value是一个固定值PRESENT。 所以修改不修改无所谓。

### HashSet：

顾名思义，底层使用了哈希算法

哈希算法：Hash，一般翻译做散列、杂凑，或音译为哈希，**是把任意长度的[输入](https://baike.baidu.com/item/输入/5481954)（又叫做预映射pre-image）通过散列算法变换成固定长度的[输出](https://baike.baidu.com/item/输出/11056752)，该输出就是散列值。**这种转换是一种[压缩映射](https://baike.baidu.com/item/压缩映射/5114126)，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的[消息摘要](https://baike.baidu.com/item/消息摘要/4547744)的函数。‘

HashSet底层使用了一个HashMap来执行操作，所有对Set的操作转化为对Map中的key进行操作，Value则有一个统一的值：

```java
private static final Object PRESENT = new Object();
```

在使用HashSet时需要重写equals（）和hashCode（）方法以确保放入Set对象的唯一性。

Set内部是无序的，只能通过迭代的方式获得其中的元素。

### LinkedHashSet：

与HashSet相同，底层数据结构是LinkedHashMap，在初始化时设置变量

```java
final boolean accessOrder；
```

false表示迭代时使用插入顺序。

此外，为了保存插入顺序，LinkedHashSet增加了链表结构，故效率下降。

### TreeSet：

底层使用Treemap，TreeSet中存放的元素是有序的（非插入顺序，按关键字大小排序），往往需要实现Comparable接口，重写compareTo方法。

TreeSet实现了SortSet接口，其底层采用了红黑树，即满足以下红黑性质的二叉搜索树：

1. 每个节点或红或黑；
2. 根节点黑色；
3. 叶结点均为黑色且null；
4. 如果一个节点是红色的，那么他的两个子节点是黑色的（红黑树无相邻的红色节点）；
5. 对每个节点，从该节点到其所有的后代叶子结点的简单路径上，仅包含相同数目的黑色结点；
6. 新加入红黑树的节点爵位红色节点。

TreeSet包含两种排序方式：

- 自然排序：实现了Comparable接口，所以TreeSet可以调用对象的ComparableTo()方法来比较集合的大小，然后进行升序排序，这种排序方式叫做自然排序。其中实现了Comparable接口的还有BigDecimal、BigInteger、Byte、Double、Float、Integer、Long、Short（按照数字大小排序）、Character（按照Unicode值的数字大小进行排序）String（按照字符串中字符的Unicode值进行排序）类等。

- 客户端排序：其实就是实现java.util.Comparator<Type>接口提供的具体的排序方式，<Type> 是具体要比较对象的类型，他有个compare的方法，如compare(x,y)返回值大于0表示x大于y，以此类推，当我们希望按照自己的想法排序的时候可以重写compare方法。

  ```java
  Collections.sort(list,new Comparator<String>(){
  	@Override
  	public int compare(String o1,String o2){
          return Integer.parseInt(o2) - Integer.parseInt(o1);
      }
  })
  ```

  

## Map:

java的Map(映射)是一种把键对象和值对象进行映射的集合，其中每一个元素都包含了键对象和值对象，其中**值对象也可以是Map类型的数据**，因此，**Map支持多级映射**，Map中的**键是唯一**的，但**值可以不唯一**，Map集合有两种实现，一种是利用哈希表来完成的叫做HashMap，它和HashSet都是利用哈希表来完成的，区别其实就是在哈希表的每个桶中，HashSet只有key，而HashMap在每个key上挂了一个value；另一种就是TreeMap，它实现了SortMap接口，也就是使用了红黑树的数据结构，和TreeSet一样也能实现自然排序和客户化排序两种排序方式，而哈希表不提供排序。

### HashMap：

HashMap的底层数据结构为数组+链表/红黑树，允许使用null键和值。

HashMap的增删查改操作的时间复杂度都被认为是O（1），不过常数项很大，因为哈希函数在计算时代价较高。

![image-20200918215343938](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200918215343938.png)

**数组的特点：查询效率高，插入，删除效率低**。

**链表的特点：查询效率低，插入删除效率高**。

除了链地址法，我们还可以使用开放地址法来解决哈希冲突问题：

开放地址法：**当冲突发生时，查找冲突位置的下一个空位，将数据填入。**

在HashMap底层使用数组加（链表或红黑树）的结构完美的解决了数组和链表的问题，使得查询和插入，删除的效率都很高。

#### 红黑树

二叉搜索树：

**特性：**

- 某节点的左子树节点值仅包含小于该节点的值
- 某节点的右子树节点值仅包含大于该结点的值
- 左右子树也必须是二叉查找树

问题：二叉查找树可能会出现畸形树，不够平衡，导致时间复杂度随着一个子树的高度线性增长。

红黑树就是为了解决这一问题出现的，为了达到树的平衡。

红黑树是一个自平衡的二叉查找树，每个树上的节点都遵循下面的规则：

- 每个节点都是红色或黑色的
- 树的根始终是黑色的（黑土地孕育黑树根）
- 没有两个相邻的红色节点
- 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点

**操作：**

- recolor（重新上色）
- rotation（旋转）：树平衡的关键

对树做了修改后（插入/删除/更新节点值），我们首先尝试recolor，如果recolor不能保证红黑树的四个特点，就尝试rotation。

假设我们新插入的节点是X：

1. 将新插入的节点标记为红色
2. 如果X是根节点，则标记为黑色
3. 如果X不是根节点：
   1. 如果X的Parent和Uncle都为红色：
      1. 将Parent和Uncle标记为黑色
      2. 将grand parent标记为红色
      3. 让X的颜色与Grand Parent相同，重复步骤2，3
   2. 如果Parent为红色，Uncle是黑色
      1. 
   3. 存储过程：

```java
HashMap<String,String> map = new HashMap<String,String>();
map.put("刘德华","张惠妹");
map.put("张学友","大S");
```

现在我要把键值对 “刘德华”,”张惠妹”存入map:

第一步：计算出键“刘德华”的hashcode，该值用来定位要将这个元素存放到数组中的什么位置.

**什么是hashcode？**

在Object类中有一个方法:

```
public native int hashCode();
```

该方法用native修饰，所以是一个本地方法，所谓本地方法就是非java代码，这个代码通常用c或c++写成，在java中可以去调用它。

调用这个方法会生成一个int型的整数，我们叫它哈希码，哈希码和调用它的对象地址和内容有关.

**哈希码的特点是:**

**对于同一个对象如果没有被修改（使用equals比较返回true）那么无论何时它的hashcode值都是相同的**

**对于两个对象如果他们的equals返回false,那么他们的hashcode值也有可能相等**

明白了hashcode我们再来看元素如何通过hashcode定位到要存储在数组的哪里，通过hashcode值和数组长度取模我们可以得到元素存储的下标。

刘德华的hashcode为20977295 数组长度为 16则要存储在数组索引为 20977295%16=1的地方

![img](https://picb.zhimg.com/80/v2-30f3d3b9e622dff404ee57d38234d7e6_720w.jpg)

可以分两种情况:

1. 数组索引为1的地方是空的，这种情况很简单，直接将元素放进去就好了。

2. 已经有元素占据了索引为1的位置，这种情况下我们需要判断一下该位置的元素和当前元素是否相等，使用equals来比较。

如果使用默认的规则是比较两个对象的地址。也就是两者需要是同一个对象才相等，当然我们也可以重写equals方法来实现我们自己的比较规则最常见的是通过比较属性值来判断是否相等。

**如果两者相等则直接覆盖**，**如果不等则在原元素下面使用链表的结构存储该元素**

![img](https://pic2.zhimg.com/80/v2-dd1f0d999196e9b46d9c80a0cc1ec5f0_720w.jpg)

每个元素节点都有一个next属性指向下一个节点，这里由数组结构变成了数组+链表结构,红黑树又是怎么回事呢？

Java8之后，因为链表中元素太多的时候会影响查找效率，所以当链表的元素个数达到8的时候使用链表存储就转变成了使用红黑树存储，原因就是**红黑树是平衡二叉树，在查找性能方面比链表要高**.

负载因子等于0.75的情况下根据泊松分布,单个hash槽内元素个数为8的概率小于百万分之一，所以将7作为一个分水岭，等于7的时候不转换，大于等于8的时候才进行转换，小于等于6的时候就化为链表。

**HashMap中的两个重要的参数：**HashMap中有两个重要的参数：**初始容量大小和加载因子**，初始容量大小是创建时给数组分配的容量大小，默认值为16，**用数组容量大小乘以加载因子得到一个值，一旦数组中存储的元素个数超过该值就会调用rehash方法将数组容量增加到原来的两倍，专业术语叫做扩容**.

**在做扩容的时候会生成一个新的数组，原来的所有数据需要重新计算哈希码值重新分配到新的数组，所以扩容的操作非常消耗性能.**

所以，和大多数集合相同，我们可以为集合设置合理的初始容量大小来尽量减少扩容。

此外，HashMap经常被拿来与HashTable做对比，它们的区别如下：

1. 线程安全：HashMap不是，HashTable是。

2. null键：HashMap允许，但不建议使用，HashTable不允许。

3. 继承结构：HashMap是对Map接口的实现，而HashTable还额外实现了Dictionary抽象类

4. 初始容量与扩容：HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。HashMap扩容时是当前容量翻倍即:capacity * 2，Hashtable扩容时是容量翻倍+1即:capacity * 2 + 1。

5. hash算法不同：

   Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模；

   HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取模。

**为什么HashMap底层数组要保证是2的n次方？**

因为在得到Hash值之后，HashMap还会进一步的计算hash值（HashTable则不会）

```java
hash = h & (n-1);
```

n为数据长度，在与运算过程中，若n非2的倍数，则n-1的低位不可能全为1，这样hash的结果（即数组索引）就会分布不均匀，更容易出现空桶，造成空间浪费，在数组未满的情况下使用链表甚至红黑树，效率降低。

**HashMap无缩容机制。**

### LinkedHashMap：

LinkedHashMap继承了HashMap类，是HashMap的子类。LinkedHashMap的大多数方法的实现直接使用了父类HashMap的方法。

LinkedHashMap可以说是HashMap和LinkedList的集合体，既使用了HashMap的数据结构，又借用了LinkedList双向链表的结构。

我们发现LinkedHashMap中并没有操作数据的方法,也就是说,它操作集合,使用的是HashMap的方法,只是在细节上有以下不同，它比HashMap多了两个属性:

```java
//链表的头结点
private transient Entry<K,V> header;
//该属性指取得键值对的方式,是个布尔值,false表示插入顺序,true表示访问顺序,也就是访问次数.
private final boolean accessOrder;
```

LinkedHashMap的Entry类继承了HashMap的Entry,并在此基础上进行了扩展,它拥有以下属性：

```java
K key;
V value;
Entry<K, V> next;
int hash;
//LinkedHashMap特有的两个属性
Entry<K, V> before;
NEtry<K, V> after;
```

前面的四个属性,是从HashMap中继承过来的,后面的两个是LinkedHashMap独有的,在这里需要明确next,before,after这三个属性的意思：

next是用于维护HashMap指定table位置上连接的Entry顺序的;

before、after是用于维护Entry插入的先后顺序的.

正是因为before、after和header的存在,LinkedHashMap才形成了循环双向链表.

需要注意的是,header节点,是LinkedHashMap的一个属性,它并不保存key-value内容,它是双向链表的入口.

### TreeMap：

TreeMap 是通过红黑树实现的。

TreeMap 继承于AbstractMap，是一个key-value集合。

TreeMap 实现了NavigableMap接口，意味着它支持一系列的导航方法。比如返回有序的key集合。

TreeMap 实现了Cloneable接口，意味着它能被克隆。

TreeMap 实现了java.io.Serializable接口，意味着它支持序列化。

java.util.concurrent

#### 抽象类和接口的区别：

从上到下：

- 抽象类可以有有构造方法，接口中不能有构造方法
- 抽象类可以有普通成员变量，接口中没有普通成员变量
- 抽象类中可以有普通方法，接口中所有方法都必须是抽象的**（1.8后接口增加了default方法，该方法可以直接被实现类调用/重写）**
- 抽象类中的抽象方法可以是除private修饰词外的任意修饰词，接口中的抽象方法只能是public
- 抽象类中可以有静态方法，接口中不行**（1.8后相同）**
- 抽象类和接口中都可以有静态成员变量，但抽象类的访问类型可以是任意的，而接口中的访问类型只能且默认为public static final
- 一个类可以实现多个接口，但只能继承一个抽象类

猜想：Java8对于接口的增强可能是为了使之前版本的JDK兼容Java8的函数式接口。

##### 应用方面：

接口更多的是在系统架构设计方法发挥作用，用于定义模块之间的通信契约。

抽象类在代码实现方面发挥作用，可以实现代码的重用，模板方法设计模式是抽象类的一个典型应用，假定某个项目的所有Servlet类都要用相同的方式进行权限判断，记录访问日志和处理异常，这时就可以定义一个抽象的基类，在基类中定义功能代码，让Servlet子类继承该基类并实现自己的逻辑。

# 计算机网络

## 从输入URL到浏览器页面加载完成都发生了些什么

### 从浏览器接收URL到开启网络请求线程

浏览器是多进程的，包括：

- 一个主控进程
- 插件进程
- GPU进程
- 浏览器内核进程（每个TAB页一个，有些情况下会合并多个进程），而浏览器内核又是多线程的
  - GUI线程
  - JS引擎线程
  - 事件触发线程
  - 定时器线程
  - 网络请求线程

在输入一个URL请求后，浏览器会开启一个单独的线程，在解析URL后，由该线程发起网络请求。

### 从开启一个网络请求线程到发出一个完整的http请求

通过DNS查询得到IP地址：

- 用户输入的往往是域名，需要进行DNS解析，先由缓存查询，缓存没有再去DNS服务器查。
  - ![image-20201201161109183](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20201201161109183.png)
  - 根服务器包含所有顶级域名服务器的域名和ip，他往往不会直接转换IP而是告诉用户该去哪找。
  - 顶级域名服务器（org，com，edu），可能给出结果或告知下一步查找的IP。
  - 权限域名服务器（abc.com,y.abc.com）
  - 本地域名服务器：用户发送DNS解析请求的对象，距离用户很近（互联网服务提供商或大学都可以拥有一个本地域名服务器）
- HTTP请求本质上其实是TCP/IP请求，发送HTTP请求需要建立TCP连接（三次握手）
- 客户端发送HTTP请求
- 服务器发送HTTP响应
- 浏览器渲染页面
- 关闭TCP连接（四次挥手）

## 跨域问题

### 浏览器同源策略

同源策略规定某域下的客户端在没有明确授权的情况下，不能读写另一个域的资源。

在前后端分离的项目中，如果不做特别处理，前端就无法收到后端返回的数据。

同源一般要求两个URL的协议+域名+端口相同，两个域名指向同一个IP地址，也非同源。

同源策略/SOP（Same origin policy）是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，现在所有支持 JavaScript 的浏览器都会使用这个策略。如果缺少了同源策略，浏览器很容易受到 XSS、 CSFR 等攻击。

浏览器不会拒绝非同源脚本发出请求，但会拒绝该脚本接收返回数据。

### 解决方案

1. Cross Origin Resource Share（CORS）

   增加请求头和响应头，安全的进行传输

   | 请求头                         | 含义                                                       |
   | ------------------------------ | ---------------------------------------------------------- |
   | Origin                         | 跨域或预先请求时的源域名                                   |
   | Access-Control-Request-Method  | 跨域请求使用的实际HTTP方法                                 |
   | Access-Control-Request-Headers | 预先请求时，告知服务器要发起的跨域请求中会携带的请求头信息 |
   | with-credentials               | 跨域请求携带的cookie                                       |

   | 响应头                        | 含义                                                        |
   | ----------------------------- | ----------------------------------------------------------- |
   | Access-Control-Allow-Origin   | 服务端验证后的允许的跨域请求域名可以是特定的也可以是任意的* |
   | Access-Control-Expose-Headers |                                                             |
   | Access-Control-Max-Age        |                                                             |
   | Access-Control-Allow-Methods  |                                                             |

   

Linux

计网

操作系统

设计模式

单例 工厂































# JVM

## 1.java类的加载机制

### 1.1 什么是类的加载

类的加载指将类的.class文件中的**二进制数据**读入到内存，将其放在运行时数据区的**方法区**内，随后在**堆区**创建一个java.lang.class对象，用以封装类在**方法区内的数据结构**。

类加载的最终产品是**位于堆区的Class对象**，Class对象封装了类在**方法区内的数据结构**，并向Java程序员提供了访问方法区的数据结构的接口。

类加载器并非真正的懒加载，JVM允许加载器在预料某个类要被使用时就预先加载他。如果加载遇到问题，类加载器必须在程序首次使用该类时才报错（LinkageError），不被使用则不会报错。

加载.Class文件的多种方法：

- 从本地系统中直接加载
- 通过网络下载
- 从zip，jar等归档文件中加载
- 从专有数据库中提取
- 将Java源文件动态编译为.class文件

### 1.2 类的生命周期

类加载的过程包括**加载，验证，准备，解析，初始化**五个阶段，**解析**发生的顺序是不确定的，有时他可以发生在**初始化**阶段之后（为了支持Java的动态绑定）。此外，这几个阶段是按顺序开始的，而非按顺序完成，通常会在一个阶段执行过程中调用或激活另一个阶段。

- 加载

  加载阶段，虚拟机需要完成以下三个工作：

  - 通过一个类的全限定名来获取其定义的二进制字节流
  - 将字节流代表的静态存储结构转化为方法区的运行时数据结构
  - 在堆中生成一个代表该类的java.lang.class对象，作为对方法区数据结构的访问入口

  加载阶段是类加载周期中可控性最强的阶段，开发人员既可以使用系统提供的类加载器也可以自定义加载器。

- 连接

  - 验证

    验证是连接阶段第一步，用于**确保Class文件符合JVM需求，并且不会危害虚拟机**，验证阶段有四个动作：

    - 文件格式验证
    - 元数据验证
    - 字节码验证
    - 符号引用验证

    验证阶段很重要，但不是必须的，如果该加载类经过多次验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机的类加载时间。

  - 准备

    **为类的静态变量分配内存，并将其初始化为默认值**，注意：

    - 此时进行内存分配的变量只有static修饰的变量，并不包括实例变量，实例变量会在对象实例化时随对象一块分配在Java堆中。
    - 这里所说的初值指数据类型的默认值，而非代码中显式赋予的值。

    数据赋值小贴士：

    ```
    对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。
    
    对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。
    
    对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。
    
    如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。
    ```

    - 如果类字段的字段属性表中存在 `ConstantValue`属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。

  - 解析

    将类中的符号引用转化为直接引用

    - 符号引用即一组符号来描述目标，可以是任何字面量。
    - 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

- 初始化

  初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：

  - 声明类变量是指定初始值
  - 使用静态代码块为类变量指定初始值

  JVM初始化步骤

  - 假如这个类还没有被加载和连接，则程序先加载并连接该类
  - 假如该类的直接父类还没有被初始化，则先初始化其直接父类
  - 假如类中有初始化语句，则系统依次执行这些初始化语句

  类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：

  - 创建类的实例，也就是new的方式
  - 访问某个类或接口的静态变量，或者对该静态变量赋值
  - 调用类的静态方法
  - 反射（如 `Class.forName(“com.shengsiyuan.Test”)`）
  - 初始化某个类的子类，则其父类也会被初始化
  - Java虚拟机启动时被标明为启动类的类（ `JavaTest`），直接使用 `java.exe`命令来运行某个主类

- 结束生命周期

  在如下几种情况下，Java虚拟机将结束生命周期

  - 执行了 `System.exit()`方法
  - 程序正常执行结束
  - 程序在执行过程中遇到了异常或错误而异常终止
  - 由于操作系统出现错误而导致Java虚拟机进程终止

### 1.3 类加载器

站在Java虚拟机的角度来讲，只存在两种不同的类加载器：

- 启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；

- 所有其它的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类 `java.lang.ClassLoader`，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。

站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：

**启动类加载器**： `BootstrapClassLoader`（C语言实现），负责加载存放在 `JDK\jre\lib`(JDK代表JDK的安装目录，下同)下，或被 `-Xbootclasspath`参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被 `BootstrapClassLoader`加载）。启动类加载器是无法被Java程序直接引用的。
**扩展类加载器**： `ExtensionClassLoader`，该加载器由 `sun.misc.Launcher$ExtClassLoader`实现，它负责加载 `JDK\jre\lib\ext`目录中，或者由 `java.ext.dirs`系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。
**应用程序类加载器**： `ApplicationClassLoader`，该类加载器由 `sun.misc.Launcher$AppClassLoader`来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：

- 在执行非置信代码之前，自动验证数字签名。
- 动态地创建符合用户特定需要的定制化构建类。
- 从特定的场所取得java class，例如数据库中和网络中。

JVM类加载机制

- **全盘负责**：当一个类加载器负责加载某个Class时，该Class所依赖和引用的所有Class也将由该加载器负责，除非显式的使用另一个加载器来加载。

- **父类委托**：先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径加载。

- **缓存机制**：保证所有加载过的Class都被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，若不存在再重新加载，这也是为什么每次修改了Class代码后，必须重启JVM，修改才会生效。

### 1.4 类的加载

类加载有三种方式：

- CMD启动应用时由JVM初始化加载
- 通过Class.forName()动态加载
- 通过ClassLoader.loadClass()动态加载

```java
package
com.neo.classloader;

public class loaderTest {
	public static void main(String[] args) throws ClassNotFoundException{
		ClassLoader loader = HelloWorld.class.getClassLoader();       
		System.out.println(loader);          
		//使用ClassLoader.loadClass()来加载类，不会执行初始化块 
		loader.loadClass("Test2");
         
		//使用Class.forName()来加载类，默认会执行初始化块           
		//Class.forName("Test2"); 
          
		//使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块           
		//Class.forName("Test2", false, loader);    
	}
}
```

**Class.forName()和ClassLoader.loadClass()区别**

- `Class.forName()`：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；
- `ClassLoader.loadClass()`：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。
- `Class.forName(name,initialize,loader)`带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。

### 1.5 双亲委派模型

如果一个类加载器收到了类加载请求，那么他会将请求委托给父加载器。因此所有的类加载请求最终都应该被传至启动类加载器，只有当父加载器没有在他的搜索范围内找到所需的类时，子加载器才会尝试自己去加载该类。

意义：

- 系统类需要防止内存中出现多份相同的字节码
- 保证Java程序安全稳定的运行

### 1.6 自定义类加载器

通常情况下，默认类加载器可以满足我们的需求，但在某些情况下，我们需要自定义加载器来完成特别的功能。

如：应用通过网络传输来获取Class的字节码，而为了保证安全性，这些字节码都是被加密过的，我们就需要自定义类加载器来解密并加载该类。

自定义加载器一般继承于ClassLoader类，我们只需要重写其中的findClass方法即可。

- 传递的文件名应是全限定名（com.paddx.test.classloading.Test），因为defineClass方法是按这种方式识别的。
- 尽量不要重写loadClass方法，易破坏双亲委托模式。
- 这类Test 类本身可以被 `AppClassLoader`类加载，因此我们不能把 `com/paddx/test/classloading/Test.class`放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 `AppClassLoader`加载，而不会通过我们自定义类加载器来加载。

## 2. JVM的内存结构

JVM内存结构主要有三大块：**堆内存**、**方法区**和**栈**。堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，**Eden空间**、**From Survivor空间**、**To Survivor空间**,默认情况下年轻代按照**8:1:1**的比例来分配；

方法区存储类信息、常量、静态变量等数据，是线程共享的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)；栈又分为java虚拟机栈和本地方法栈主要用于方法的执行。

<img src="https://mmbiz.qpic.cn/mmbiz_png/PgqYrEEtEnoUSbbnzEiafyyQWUibOfnE3GQ0NibDSK0gTV91vOLkOGUBM9h9nTHTJ9YfzVonOicI9c1N2cCpG4j5Mg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" style="zoom:150%;" />

- -Xms设置堆的最小空间大小。
- -Xmx设置堆的最大空间大小。
- -XX:NewSize设置新生代最小空间大小。
- -XX:MaxNewSize设置新生代最大空间大小。
- -XX:PermSize设置永久代最小空间大小。
- -XX:MaxPermSize设置永久代最大空间大小。
- -Xss设置每个线程的堆栈大小。

没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。

> 老年代空间大小 = 堆空间大小 - 年轻代大空间大小



**JVM和系统调用之间的关系**：

![img](https://mmbiz.qpic.cn/mmbiz_png/PgqYrEEtEnoUSbbnzEiafyyQWUibOfnE3G1sZG1aJZSakhFe5d6QeiciaO9ZIDfHrFS9UZx8RfWfkPk9UZLCVdcriaQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

方法区和对是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。

### **Java Heap（堆）**

Java堆是JVM管理的内存中**最大**的一块。堆是所有线程共享的一块内存区域，在JVM启动时即创建，唯一目的就是存放对象实例，**几乎所有的对象实例都在这里分配内存**。

堆是垃圾收集器管理主要区域，很多时候也被叫做**“GC堆”**。从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；（新生代8：1：1）更细致的有Eden空间、From Survivor空间、To Survivor空间。

Java堆可以处于物理上不连续的空间，逻辑连续即可。实现时，既可以为固定大小，也可以是可扩展的（主流虚拟机使用-Xmx和-Xms来实现扩展）。

若堆中没有内存完成实例分配，且堆也无法再扩展，就会抛出OutOfMemoryError异常。

### **方法区（Method Area）**

方法区与堆一样，都是线程共享区域，用于存储**已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据**。

也可以称方法区为非堆（Non-Heap）,用于与Java堆区分开。

对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation）/ “持久代”（PermGen），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。

Java虚拟机规范对这个分区非常宽松，除了无需连续内存和可扩展外，还可以选择**不实现垃圾回收**。相对而言，垃圾收集行为在这个区域是比较少出现的，这个区域的垃圾回收主要针对常量池的回收和对类型的卸载。这个区域的垃圾回收收效甚微，尤其是类型的卸载，条件相当苛刻，但也是有必要的。

无法分配内存需求时，也会抛出OutOfMemoryError。

### **程序计数器（Program Counter Register）**

PCR是一块**线程独享**的较小的内存空间，它是当前线程所执行的字节码的行号指示器。在虚拟机概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能均依赖于PCR。

如果线程正在执行一个Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址；若正在执行Native方法，则计数器为空（Undefinded）。

**此区域是唯一一个在规范中没有规定任何OutOfMemoryError的区域。**

### **JVM栈（JVM Stacks）**

JVM栈是线程私有的，**它的生命周期与线程相同**。

虚拟机栈描述的是**Java方法执行的内存模型**：每个方法被执行时都会同时创建一个栈帧（Stack Frame）用于存储局部变量表，操作栈，动态链接，方法出口等信息。

**每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。**

局部变量表存放了编译期可知的各种基本数据类型，对象引用。局部变量表所需的内存空间在编译期间完成分配（long和double占用两个局部变量空间（Slot），其余的占用一个），方法运行期间该表大小不会改变。

两种异常：

- 线程请求的栈深度大于虚拟机允许的深度，抛出StackOverFlowError。
- 扩展内存时无法获得额外空间，抛出OutOfMemoryError。

### 本地方法栈（Native Method Stack）

本地方法栈和虚拟机栈很相似，本地方法栈为Native方法提供服务。

异常与虚拟机栈相同。

### OutOfMemoryError

对内存结构清晰的认识同样可以帮助理解不同OutOfMemoryErrors：

![image-20201127232001879](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20201127232001879.png)

## 3. GC算法 垃圾收集器

JVM中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的。

#### Safe Point

当程序运行到Safe Point时，线程的一些状态可以确定，从而确定GC Root的信息，使JVM可以安全的进行一些操作，比如GC。

**位置：**

- 循环末尾
- 方法返回前
- 调用方法之后
- 抛出异常的位置

### 对象存活判断

判断对象存活有两种方式：

#### 引用计数

每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，技术为零时可以回收。简单，但无法解决对象互相循环引用问题。

#### 可达性分析

从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，即不可达对象。

在Java语言中，GC Roots包括：

- 虚拟机栈中引用的对象。
- 方法区中类静态属性实体引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI（Java Native Interface）引用的对象。

GC Root特点是当前时刻存活的对象！

### 垃圾收集算法

#### 标记-清除算法

首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

后续算法均为对该算法的缺点进行改进。

缺点：

- 效率低下，标记和清楚效率都很低

- 清除过后会产生大量的非连续空间碎片


#### 复制算法

将可用内存分为大小相同的两块，每次只使用其中一块，当前块内存使用完毕后，将存活对象复制到另一块。将原内存块清空。

缺点：

- 内存利用率仅为50%
- 持续复制存活对象，效率低下。

#### 标记-压缩算法

- 老年代由于内存占用很大，不可能采用复制算法


- 压缩算法不直接清除可回收对象而是让所有存活对象向一端移动。然后直接清理掉端边界外的内存


#### 分代收集算法

- 基本假设：绝大部分对象的生命周期短暂
- 新生代中存活对象数量少，采用复制算法
- 老年代存活率高，采用标记清除/标记压缩

### 垃圾收集器

算法即方法论，收集器即具体实现

#### 新生代收集器

##### Serial收集器

- 最古老/最稳定/效率高
- 可能产生较长停顿（单线程回收）
- 复制算法
- 收集过程中会暂停服务（用户线程停用，无线程交互损耗）
- 场景：JVM在Client模式下的默认新生代收集器（专为单核CPU上的桌面应用所设计），不适用于服务器端。
- 参数控制： `-XX:+UseSerialGC`

##### ParNew收集器

- Serial收集器的多线程版本
- 复制算法
- 场景：服务器端首选的新生代收集器（主要原因是CMS是跨时代的实现了用户线程与回收线程并行的垃圾收集器，而老年代选用CMS只能搭配ParNew/Serial）
- 参数控制：
  - `-XX:+UseParNewGC` ParNew收集器
  - `-XX:ParallelGCThreads` 限制线程数量

##### Parallel Scavenge 收集器

- 与ParNew收集器类似，更关注系统吞吐量
- 可通过参数打开自适应策略，通过动态监控提供最佳停顿时间/最大吞吐量
- 可通过参数控制GC时间
- 复制算法
- 参数控制： `-XX:+UseParallelGC` 使用Parallel收集器+ 老年代串行

#### 老年代收集器

##### Serial Old 收集器

- Serial收集器的老年代版本
- 单线程，标记整理
- 场景：
  - Client端使用
  - 1.5以前与Parallel Scavenge联用
  - CMS的Concurrent Mode Failure的后备预案。

##### Parallel Old 收集器

- 是Parallel的老年代版本，使用多线程和标记-压缩算法，从JDK1.6开始提供。
- 参数控制： `-XX:+UseParallelOldGC` 使用Parallel收集器+ 老年代并行

##### CMS 收集器

- Concurrent Mark Sweep（JDK 1.5）
- 优点：并发，低停顿
- 缺点：
  - 对CPU资源敏感，默认启动的回收线程数（CPU数量+3）/ 4，CPU不足四时对用户线程影响就会过大。
  - 无法处理浮动垃圾（用户线程在CMS收集垃圾过程中产生的垃圾），由于在垃圾回收过程中用户线程还需要运行，所以CMS需要预留空间给用户线程，当预留内存不足时，就会出现“Concurrent Mode Failure”，临时启用Serial Old收集器来重新进行老年代的垃圾收集，停顿时间会变长。
  - 基于标记-清除，产生大量空间碎片。
- 以获取最短回收停顿时间为目标的收集器
- Java应用大多运行于**B/S服务端**，良好的响应速度是非常必要的。

小贴士：

```
B/S指Browser/Server，浏览器和服务器。
B/S优势在于其无需维护客户端，适用于用户群庞大，客户需求经常发生变化的情况。
C/S指Client/Server，客户端和服务器。
C/S优势在于能充分发挥用户PC的处理能力，很多工作可以由用户机来完成，减小服务器压力，适用于用户需求特别复杂的时候。
```

- CMS收集器是基于标记-清除算法实现的，运作过程相对更复杂，有四个步骤：
  - 初始标记（CMS initial mark）
  - 并发标记（CMS concurrent mark）
  - 重新标记（CMS remark）
  - 并发清除（CMS concurrent sweep）
- 初始标记，重新标记仍需要暂停服务。
- 初始标记只标记那些能够直接与GC Root相连的对象，速度很快。
- 并发标记即GC Roots Tracing过程。
- 重新标记用于修正并发标记期间由于程序员操作导致的对象状态变化（由于并发标记时间较长，所以重新标记是必要的），时间比初始标记略长，比并发标记短。
- 并发标记和清除过程中，收集器线程可以与用户线程并发执行。

#### G1收集器

- 特性：

  - 面向服务端的垃圾收集器，HotSpot开发团队希望**他未来可以替换掉CMS收集器**。

  - 并行和并发：是用户程序继续运行
  - 分代收集：G1可以利用分代收集算法独立管理整个GC堆。

  - 无空间碎片：整体基于**标记-整理算法**，局部基于**复制算法**。
  - 可预测的停顿：建立可预测的停顿时间模型，可由开发者指定垃圾收集时间不超过N毫秒。
  - 空间布局：G1的空间布局不再是单纯的新生代和老年代，它将整个Java堆划分为多个大小相等的独立区域，新生代和老年代不再物理隔离，他们都是一部分区域的集合。

- 执行过程：

  - 初始标记：**标记GC Roots的直接关联对象**，修改NTMS（Next Top at Mark Start）,确保下一阶段用户线程并发运行时在可用区域创建新对象，需要**停顿**。
  - 并发标记：GC Roots Trace，并发运行。
  - 最终标记：并发标记阶段产生变化的对象。

  - 筛选回收：首先对各个区域的回收价值和成本进行排序，根据用户期望的停顿时间指定回收计划。也可以并发执行，但为了提高效率，且时间是用户可控制的，故使用停顿。

### JStack

stack用于生成[java虚拟机](https://baike.baidu.com/item/java虚拟机/6810577)当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。

线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。

### JStat

Jstat位于java的bin目录下，主要利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控。

Jstat可以用来监视VM内存内的各种堆和非堆的大小及其内存使用量。

### JMap

Jmap命令用于生成堆转储快照，有时候也成为heapdump或者dump文件。

Jmap不仅仅可以获取dump文件，还可以查询finalize执行队列，Java堆和永久代的详细信息，如空间使用率、当时用的是那种收集器等。

### OOM问题

两个原因：

- 分配少了
- 用得太多：
  - 内存泄漏：用完没释放。
  - 内存溢出：申请的超出能分配的。































# Java线程池

[面试必备：Java线程池解析](https://zhuanlan.zhihu.com/p/73990200)

概念：管理线程的池子

优点：

- 帮助管理线程，避免增加创建线程和销毁线程的资源损耗
- 提高响应速度
- 重复利用

线程池的创建：

- 核心参数：
  - corePoolSize 核心线程最大数量
  - maximumPoolSize 线程池最大线程数量
  - keepAliveTime：线程池中非核心线程空闲的存活时间大小
  - unit：线程存活时间单位
  - wordQueue：存放任务的阻塞队列
  - threadFactory：设置创建线程的工厂，为创建线程设置有意义的名字，方便排查问题
- 线程池执行流程：execute()方法
  - 提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。
  - 如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。
  - 当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。
  - 如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。
- 四种拒绝策略
  - AbortPolicy(抛出一个异常，默认的)
  - DiscardPolicy(直接丢弃任务)
  - DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）
  - CallerRunsPolicy（交给线程池调用所在的线程进行处理)
- 线程池的异常处理可以直接使用try/catch

# Java锁

**Java中的Unsafe**

Java和C++语言的一个重要区别就是Java中我们无法直接操作一块内存区域，不能像C++中那样可以自己申请内存和释放内存。Java中的Unsafe类为我们提供了类似C++手动管理内存的能力。

Unsafe类是final修饰的，不允许继承且构造函数是private的：

```java
public final class Unsafe {
    private static final Unsafe theUnsafe;
    public static final int INVALID_FIELD_OFFSET = -1;

    private static native void registerNatives();
    // 构造函数是private的，不允许外部实例化
    private Unsafe() {
    }
    ...
}
```

Unsafe无法实例化，我们该如何获取Unsafe实例呢：

```java
//反射
public Unsafe getUnsafe() throws IllegalAccessException {
    Field unsafeField = Unsafe.class.getDeclaredFields()[0];
    unsafeField.setAccessible(true);
    Unsafe unsafe = (Unsafe) unsafeField.get(null);
    return unsafe;
}
```

Unsafe类有如下功能：

![img](https://upload-images.jianshu.io/upload_images/11963487-607a966eba2eed13.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

[java中的Unsafe](https://www.jianshu.com/p/db8dce09232d)

#### Java中的锁：

![img](https://img-blog.csdnimg.cn/20181122101753671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F4aWFvYm9nZQ==,size_16,color_FFFFFF,t_70)

1.乐观锁和悲观锁（线程是否要锁住同步资源）

对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据时会加锁，确保数据不被其他线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。

乐观锁认为自己在使用数据时不会有人来，所以不添加锁，只在更新数据时判断数据有没有被更改：

- 没被更改则更新数据
- 被更改了则报错或自动重试或根据实现策略执行

乐观锁在Java中通过无锁编程来实现，最常用的是CAS算法（Compare and Swap），比较与交换，将副本中的预期值与主存中的值比较，相等则更新，不等则重试。

CAS算法涉及到三个操作数：

- 需要读写的内存值 V。
- 进行比较的值 A。
- 要写入的新值 B。

当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。

JUC包中的原子类就使用了CAS来实现乐观锁：

```java
public class AtomicInteger extends Number implements java.io.Serializable {
    private static final long serialVersionUID = 6214790243416807050L;

    // setup to use Unsafe.compareAndSwapInt for updates
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long valueOffset;

    static {
        try {
            valueOffset = unsafe.objectFieldOffset
                (AtomicInteger.class.getDeclaredField("value"));
        } catch (Exception ex) { throw new Error(ex); }
    }

    private volatile int value;
```

- unsafe：获取并操作内存数据
- valueOffset：存储value在AtomicInteger中的偏移量
- value：存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间可见

**Java内存可见性问题：**（引入volatile关键字的原因）

首先说说线程之间内存可见性的问题，下面这个图，这是一个双核CPU架构，每个核都有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辑运算，每一个核都有自己的以及缓存，在这里所有CPU共享二级缓存（有的架构可能不会共享二级缓存），在java中每一个线程的私有空间，就是对应于这里的一级缓存；

　　缓存的作用就不用多说了吧，就是为了下一次读取的速度更快；

![img](https://img2018.cnblogs.com/i-beta/1368608/202001/1368608-20200128133942468-710146493.png)

　　那么在本架构中，如果线程A和B都要读取共享变量1，那么线程A首先会将共享变量1存到二级缓存中，再将共享变量1存到线程A的一级缓存中，此时线程A就可以计算了，此时线程B只需要在二级缓存中读取共享变量1就行了，这样速度就快多了！然后线程B再将共享变量1读取到线程B的一级缓存中，进行运算就ok了；

　　举个例子，假设这里的共享变量1的值为0，每个线程进行的操作就是+1

　　首先，线程A先会在自己的一级缓存中找有没有共享变量1，没有的话再到二级缓存中找，还没有的话就到主内存中找；于是就复制一份0到二级缓存，然后又把0复制一份到线程A的一级缓存，进行运算得到的值为1，然后将1复制给线程A的一级缓存，再复制给二级缓存，再写入到共享变量1中，此时共享变量的值是1

　　然后，线程B再到自己的一级缓存中找共享变量1，没有就去二级缓存中找，发现找到了，值为1，于是就复制一份到线程B的一级缓存中，进行+1操作之后等于2，然后把2复制给线程B的一级缓存中，再复制到二级缓存中，再写入到主内存中的共享变量1中，此时共享变量的值为2

　　**注意：**如果这个时候线程A又要进行操作，它会先在自己的一级缓存中找共享变量，发现找到了，值为1，然后进行+1操作等等....这就是坑的所在，线程A此时一级缓存中共享变量的值为1，而主内存和二级缓存中的共享变量的值已经被线程B写入为2，这就是共享变量的内存不可见问题，也就是线程B写入的值2对线程A不可见（线程A读取的还是1）

　　看懂了上面，我们就知道volatile关键字的用处了，如果一个共享变量使用volatile关键字进行修饰，那么这个线程在修改该变量的时候是不会放到一级缓存或者二级缓存中，会直接写入到主内存中，例如上面的例子中，我们可以像下面这样修改一下使用，然而最后的结果不一定是20000，因为没有保证原子性！

​		还有，使用了这个关键字之后，由于没有使用缓存了，效率略低一点，而且不能保证原子性！我们可以想象将上图中一级缓存和二级缓存去掉，那么每次还是会进行三步：从主内存中读取共享变量--->运算--->写入到主内存；这个时候就有一个问题，假设共享变量的值为1，双核CPU，线程A读取共享变量之后正在运算，此时另外一个线程同时也读取共享变量的值为1，也在计算，最后就会导致两个线程都把1写入到主内存的共享变量中，这不是我们想看到的！后面的CAS就可以解决这个问题。

**简单说说synchronized**：

　　这个关键字应该很熟悉了，就简单说一下吧，这个关键字是java提供的原子性内置锁，java中的每一个对象都可以当做一个同步器锁，其实当前只能一个线程进入synchronized块中，其他线程进不来，只能阻塞，而阻塞需要从用户态切换到内核态执行阻塞操作（这是操作系统有关的知识），这是很花费时间的，所以一般都说synchronized锁是重量级的；

　　其实后面要说的CAS就是避免线程阻塞的，更通俗的说CAS就是多个线程都不会阻塞，每个线程只会去无限循环（此处可以使用自旋锁来实现自旋一定次数后停止），当满足条件之后就会更新，避免切换线程阻塞然后还要去切换线程上下文！

　　使用synchronized关键字的话，在synchronized块中的变量都不会存到线程的局部空间中，就像volatile一样，可以看做是消除了一级缓存和二级缓存，读取直接从主内存中读取，写入也是直接写入到主内存中（在进入synchronized块中就是从主内存中读取需要用的变量，退出synchronized块就是将计算后的值写入到主内存中 ）

　　而且synchronized关键字也可以用来实现原子操作，但是会引起线程上下文切换从而导致线程调度开销。

**原子操作**

　　什么叫做原子操作呢？简单来说就是多个操作要么全部成功，要么全部失败，有点类似事务。这里基本的知识就不说了，有兴趣的可以去查查资料！

　　直奔主题CAS，全称compareAndSwap，我翻译的意思是：比较xx然后把xx换成xxx，实例的话可以看看AtomicInteger类的compareAndSet方法，这方法内部就是调用unsafe.compareAndSwapInt(this, valueOffset, expect, update);

　　可以看到compareAndSwapInt方法有四个参数，第一个参数表示对象的内存地址，第二个参数表示一个偏移量，可以根据偏移量找到变量的位置（假如对象的内存地址是112，该对象有个变量num偏移量为8，那么我们可以知道num的内存地址是120），第三个参数表示根据偏移量找到的变量的值为expect，第四个参数表示将expect更新为update；

　　随便举个例子，假设有伪代码unsafe.compareAndSwapInt(this, 3, 99, 100);表示在当前对象内存地址往后移动3个位置的值是99，那么就把99更新为100，我感觉更类似sql语句中的update xxx t set t.a=100 where t.a = 99

　　我们可以知道CAS是通过一个Unsafe来实现的，而这个类在rt.jar包中，而且该类几乎所有的方法都是native方法，可以知道是通过JNI调用本地的C艹库实现的，提供了硬件级别的原子操作。

[CAS在JUC原子类中的实现](https://www.cnblogs.com/wyq1995/p/12240777.html)













# 数据库

## 1.MySQL

### 1.1索引

#### 1.1.1底层数据结构

##### 1.1.1.1B+树

Mysql数据库索引使用B+树：

B+树是应文件系统所需而产生的一种B树的变形树（文件目录一级一级索引，只有底层的叶子节点保存数据），非叶结点只保存索引。

![image-20200922142547823](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200922142547823.png)

##### **1.1.1.2为什么不使用红黑树/AVL树？**

存放规模相同的大量数据，红黑树和AVL树深度更大，I/O过于频繁，效率低下。

##### **1.1.1.3为什么不用B树？**

1. B树与B+树不同之处在于他在非叶结点处也存储了数据（除主键以外的所有数据），如果data很大，磁盘空间有限，非叶节点能够存放的key就会变少，深度增大，最终导致，I/O次数增加。

2. 在数据库中基于范围的查询是非常频繁的，B+树底层是一个有序链表（不同磁盘块的节点是连接在一起的），只需遍历链表即可遍历整个B+树，而B树不可以。

   B树的优点：非叶节点的命中效率很高（I/O次数少），相比之下B+树的命中效率非常平稳无波动。

##### **1.1.1.4为什么不用Hash表？**

- 对于重复键值，会出现hash碰撞；
- 范围检索（包括模糊查询，如like“xxx%”）无法使用，有序的索引值在经过hash之后可能会变成不连续的，无法完成范围查询；
- 同上，无法利用hash索引来排序；

#### 1.1.2不同存储引擎实现

##### 1.1.2.1 MyISAM

- **非聚集索引**
- 可以没有主键

- 索引文件（.myi即my index）与数据文件（.myd即my data）分离
  - 非叶结点的数据文件是相对地址（B+树）

MyISAM的主索引底层结构：

![image-20200922162041625](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200922162041625.png)

可以看到，MyISAM的索引只保存数据的地址，且辅助索引和主索引的结构完全相同，只是主索引要求键是唯一的。

##### 1.1.2.2 InnoDB

- **聚集索引**
- 数据文件按主键聚集，所以必须有主键。

InnoDB的主索引底层结构：

![image-20200922162621761](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200922162621761.png)

InnoDB的辅助索引底层结构：

![image-20200922162639819](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200922162639819.png)

可以看出，InnoDB的数据文件就存储在主索引中，而辅助索引的data域存储的则是主键的值，故可以得出以下结论：

- 通过主键查询时，InnoDB的查询十分高效；
- 通过辅助索引查询时，InnoDB需要先通过辅助索引查出主键值，再在主索引中获取数据，即**回表查询**。

##### 1.1.2.3 聚集索引与非聚集索引

###### 1.1.2.3.1 聚集索引

- 数据行的物理顺序（地址顺序）与列值（主键）逻辑顺序相同（决定了下一条）
- 一个表中一般只有一个（主键索引）
- 叶结点即数据节点

###### 1.1.2.3.2 非聚集索引

- 数据行的物理顺序与列值不同
- 一个表可以拥有多个非聚集索引
- 会导致二次查询问题（第一次查询得到的依然是索引）

###### 1.1.2.3.3 索引覆盖

- 一个查询语句的执行只需从索引中获得，不必从表中读取。
- 一般通过建立联合索引来实现索引覆盖，避免回表查询。

##### 1.1.2.4 语法层面

###### 1.1.2.4.1 [创建删除索引](https://www.cnblogs.com/mengfanrong/p/4490716.html)

###### 1.1.2.4.2 Explain语句

- EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而直到Mysql是如何处理你的SQL语句，可以帮你分析查询语句或者是表结构的性能瓶颈。

- 通过explain可以得到：

         表的读取顺序、数据读取操作的操作类型、那些索引被使用、哪些索引被实际使用、表之间的引用，每张表有多少行被优化器查询。

![image-20200922194320654](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200922194320654.png)

- table：表名

- **type**：查询使用的类型**（※）**

  type中包含的值（最好到最差）：

  - system/const:可以将查询的变量转为常量，如id=1;id为主键或者唯一键。


  - eq_ref: 访问索引，返回某个单一行的数据（通常在连接时出现，查询使用的索引为主键或者唯一键）


  - ref:访问索引，返回某个值的数据，可以返回多行，通常使用等于时发生。


  - range：这个连接类型使用索引返回一个范围中的行，比如使用<或>查找东西，并且在该字段上建有索引时发生的情况（但是不一定好于index索引）


  - index:以索引顺序进行全表扫描，优点是不用排序，缺点是还要全表扫描。


  - ALL：全表扫描，应该尽量避免

- possible_keys:显示可能应用在这张表中的索引。如果为空，表示没有可能应用的索引

- key:实际使用的索引。如果为null，则没有使用索引。Mysql很少选择优化不足的索引，此时可以在SELECT语句中使用FORCE INDEX （index_name）来强制使用一个索引，或者用IGNORE INDEX（index_name）来强制忽略索引。

- key_len：使用索引的长度。在不损失精确性的情况下，长度越短越好。

- ref:显示索引的哪一列被使用了，如果可能的话，是一个常数

- rows：Mysql认为必须检索的用来返回请求数据的行数。

- Extra:关于Mysql如何解析查询的额外信息，主要有以下几种：

-  Extra中包含的值：

  - using index:使用索引，可以避免访问表，性能很高。

  - using where：使用where来过滤数据，不是所有的where clause都显示using where，如以=方式访问索引。

  - using tempory:用临时表去处理当前的查询。

  - using filesort:用到额外的排序，此时mysql会根据连接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行。（当使用order by v1,而没有用索引是，就会使用额外的排序）。

  - range checked for each record (index map:N):没有好的索引可以使用。

  - using index for group-by ：表明可以在索引中找到分组所需的所有数据，不需要查询实际的表。

##### 1.1.2.5 索引分类

###### 1.1.2.5.1 普通索引

​	由KEY或INDEX定义的索引，加快数据访问。

###### 1.1.2.5.2 唯一索引

​	确定该字段无重复值时用UNIQUE字段定义为唯一索引，主要用于避免数据重复而非提高访问速度。

###### 1.1.2.5.3 主键索引

​	唯一索引的特殊类型，每个表只有一个。

###### 1.1.2.5.4 Hash索引

​	![image-20200922195921560](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200922195921560.png)

![image-20200922200023092](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200922200023092.png)

![image-20200922200033372](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200922200033372.png)

##### 1.1.2.6 最左匹配原则

![image-20200922202311583](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200922202311583.png)

![image-20200922202434906](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200922202434906.png)

### 1.2 事务（⭐⭐⭐⭐⭐）

事务：对数据库中一系列操作进行统一的回滚或提交，保证数据的完整性和一致性。

#### 1.2.1 ACID

- 原子性（Atomicity）：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被[回滚](https://baike.baidu.com/item/回滚)到事务开始前的状态。
- 一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有变化。如A向B转账，不可能A扣了钱，B却没收到。
- 隔离性（Isolation）：多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。如A正在从一张银行卡中取钱，在A取完之前，B不能向这张卡转账。
- 持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。

#### 1.1.2 事务并发操作会带来的问题

**提交：**

- 自动提交：把每条语句当作一个事务，自动完成。

- 手动提交：在你显式提交之前的所有语句都被认为是一个事物，优点是如果某一条语句失败了，整个事务都会回滚，有利于保持数据库的一致性（Consistency）。

  手动提交一般存在于显式事务中：当使用start transaction和 commit语句时则表示发生显式事务。

##### 1.1.2.1 脏读

​	一个事务读取另外一个事务还没有**提交**的数据（读到了没有提交的数据）。

##### 1.1.2.2 不可重复读

​	在一个事务中前后两次读取的结果并不一致（中间有其他事务的提交）。

##### 1.1.2.3 幻读

 和不可重复读类似，幻读指一条特定的where语句前后两次查询的结果集数量不一致（其他事务提交了一条恰好满足where条件的数据，仅涉及插入和删除，不涉及修改数据）。

- 脏读和不可重复读：未提交和已提交的修改结果

- 不可重复读与幻读：修改和插入/删除

#### 1.1.3 事务的隔离级别

##### 1.1.3.1 读未提交（Read Uncommited）

​	最低的隔离级别，允许其他事务看见没提交的数据，会导致脏读。

##### 1.1.3.2 读已提交（Read Commited）

- 被读取的数据可以被其他事务修改

  在事务读取时获取读锁，读后即释放，不需要等待事务结束，在此期间数据可能被修改。

-  会导致不可重复读

- SQL Server/Oracle的默认隔离级别

##### 1.1.3.3 可重复读（Repeated Read）

- 所有被select的数据均不可修改
- 会导致幻读（新增符合条件的记录）
- MySQL的默认隔离级别

##### 1.1.3.4 串行化（Serializable）

- 所有事务一个接着一个的执行
- 可避免幻读
- 串行化在范围查询时会获取范围锁，不基于锁实现并发操作的数据库，会回滚所有违反串行操作的事务

##### 1.1.3.5 可重复读-实现原理MVCC

###### 1.1.3.5.1 MVCC

- Multi-Version Concurrency Control 多版本并发控制
- MySQL使用MVCC来实现默认的可重复读事务隔离级别

每个接入数据库的人，在某个瞬间看到的都是数据库的一个**快照**，写操作造成的变化在完成之前对其他的读者来说是不可见的，当数据库需要新增数据记录时，他不会覆盖旧数据，而是标记旧数据为过时（obsolete），并在别处新增数据。这样就可以储存多个版本的数据，但只有一个是最新的。

优点：

- 允许读者读取之前的数据，即使这些数据被修改删除，也没有影响
- 避免了填充/删除操作在内存和磁盘中造成的空洞开销

缺点：

- 需要定期维护过期数据

###### 1.1.3.5.2 MySQL底层实现

![image-20200923222345415](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200923222345415.png)

### 1.3 MySQL中的锁

- 多线程数据库的统一解决方案（大多数）
- mysql的锁可以分为服务层实现的锁，例如Lock Tables、全局读锁、命名锁、字符锁，或者存储引擎的锁，例如行级锁。

- 锁的分类按照特性有多种分类，常见的比如显式锁和隐式锁；表锁和行锁；共享锁和排他锁；乐观锁和悲观锁等等。

### 服务级别锁：

**表锁（读写锁）：**

- 表锁有显式和隐式

- 显式锁使用Lock Table来创建 操作之后用UnLock来释放
- Lock Tables分为read和write两种
- read被称为共享锁多个用户可同时使用且不堵塞
  - 不会阻塞其他线程的读取，会阻塞其他线程对数据变更
  - 只允许对表进行**查询**操作
  - **不允许访问未被锁住的表**
- write被称为排他锁同一时间只有一个用户可以拥有锁
  - 阻塞其他线程的读和写
  - 允许对锁住的表进行**增删查改**
  - **不允许访问未被锁住的表**

《高性能MySQL》

在事务禁用AUTOCOMMIT时，可以使用LOCK TABLES关键字，其他任何时候都不要显式地执行LOCK TABLES，不论什么存储引擎。

**全局读/写锁：**

- FLUSH TABLES WITH READ/WRITE LOCK
- **重量级锁** 主要用于数据库备份
- 全局读锁其实就相当于用读锁同时锁住所有表。
- 如果当前线程拥有某个表的写锁，则获取全局写锁的时候会报错。
- 如果其他线程拥有某张表的写锁，则全局读锁会阻塞等待其他表释放写锁。

**InnoDB锁**（MyISAM只有表锁）：

行锁：比表锁粒度更小，更好的支持并发；但加锁动作也需要系统资源，会影响系统性能。

间隙锁（GAP）：当使用范围条件来检索数据时（where），InnoDB会给符合条件的数据的索引项加锁，对于键值在条件范围内但索引不存在的记录，称为“间隙（GAP）”。InnoDB同样会给间隙加锁，无法在此时插入锁定范围内的任何数据。一些情况下，间隙锁会造成系统性能下降。

**死锁**：

四个必要条件：

- 互斥：

  资源被占用以后，请求者只能等待占用者释放该资源

- 请求和保持条件：

  当前进程已保持一个资源，又提出了新的对已被占用资源的请求，当前进程阻塞且不释放保持资源

- 不剥夺条件：

  进程已获得的资源在未使用完之前，不能被剥夺

- 环路等待条件：

  形成了进程——资源的环形链

如何减少数据库死锁？

- 并发事务按同一顺序访问对象

- 避免在事务中出现用户交互（用户不在）

- 保持事务简短并保持在一个批处理中

  - ## 数据库批处理

    **批处理(batch)指的是一次操作中执行多条SQL语句，批处理相比于一次一次执行效率会提高很多。**

    **批处理操作数据库的过程主要是分两步：**

    - 将要执行的SQL语句保存
    - 执行保存的SQL语句

- 使用低隔离级别

- 使用绑定连接

### 1.4 存储引擎

#### 1.4.1 MyISAM与InnoDB的使用场景

|                   | MyISAM                                                       | InnoDB                                                       |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 构成              | 每个MyISAM表储存为三个文件：**.frm**(frame)存储表定义；**.myd**(mydata)存储表数据；**.myi**(myindex)存储表索引。 | 在磁盘上的资源包括数据文件和日志文件；表大小只受限于操作系统文件大小，一般为2GB。 |
| 事务              | 强调性能，执行速度快，不支持事务                             | 支持事务，外键等高级数据库功能                               |
| 操作              | 适合大量SELECT执行；LOAD DATA FROM MASTER是在建立主从服务器以后，在从服务器上发起的命令，目的是将主服务器中的数据复制到从服务器，只对MyISAM表有效。 | 1.适合大量INSERT/UPDATE执行；2.**DELETE FROM TABLE**时，InnoDB是一条条删除，不释放空间，而MYISAM是**TRUNCATE TABLE TB**，即新建表结构。；3.LOAD DATA FROM MASTER对于InnoDB不适用，解决方法是先改为MyISAM表，导入数据后再改回来，不过对于使用了InnoDB额外特性的表无效（如外键）。 |
| 具体行数（count） | 所有行数作为常量保存，直接读取；按条件读取行数两种表操作相同。 | 无论哪种均扫描全表。                                         |
| 锁                | 表锁                                                         | 提供行锁；不能确定扫描范围时仍然锁全表（例如LIKE关键字）     |

### 1.5 读写分离

- 概念：即主从数据库，将读取操作放到从数据库里，把增删操作放到主数据库中，将主数据库中的数据通过底层同步到从数据库里。

- 原因：读多写少，读往往是数据库的瓶颈，为了消除读写锁冲突，故采用读写分离的分组架构。
- 实现：Spring可以使用AOP切片来实现读写分离。

### 1.6 MySQL中的数据结构

#### 1.int(11)与int(3)区别在于补零位数，不影响存储精度。

#### 2.double(m,d)的含义：

​	m-d表示整数限制

​	d表示小数最高的显示精度

​	如:double(5,2)取值范围为-999.99到999.99

#### 3.char和varchar的区别

​	char存储定长数据，若数据长度不足则在其后补充空格，检索之后会删除空格，占用空间不因数据长度而发生变化，索引效率较高；

​	varchar存储非定长数据，根据数据长度分配空间，索引效率相对较低，需要额外一个字节来存储数据长度（超过255则需要两个）

#### 4.左右连接

![image-20201012171414793](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20201012171414793.png)

5.数据库范式

- 第一范式

  - 每一列都是不可分割的基本数据项
  - 关系型数据库的必需条件

- 第二范式

  - 必须满足第一范式
  - **非主属性必须完全依赖于主键**

  完全依赖：主键由多个属性构成，完全依赖要求不存在非主属性依赖于主键中的某一部分

- 第三范式

  - 必须满足第二范式
  - 属性不依赖于其他非主属性

6.UUID可以做主键吗？优势和劣势在哪?

- UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。
- 优势：无规律，难以被破解。
- 缺点：浪费存储和索引性能。



# WEB开发

## 1.基础知识

### 1.1Cookie和Session

#### 1.1.1区别

- Cookie和Session的出现都是为了解决HTTP1.0的无状态保存问题（HTTP1.0引入了Cookie机制）

- Cookie保存在客户端；Session保存在服务端

- Java中的Session和Cookie

  ```java
  HttpSession session = httpServletRequest.getSession() //创建|获取Session
  String username = (String) session.getAttribute(String name) //获取Sesion
  ```

  ```java
  cookie = new Cookie(String name,String value) //设置Cookie
  ```

- 由于保存位置不同，Session较安全而Cookie不安全
- 容量不同：
  - 单独的cookie<=4KB，一个站点最多保存20个Cookie
  - Session无上限，但为性能考虑，Session不要存储太多东西，并且需要删除机制
- 服务器压力不同，并发用户多的情况下，Session服务器压力很大

#### 1.1.2 Session实现方式？

- 通过Cookies实现，创建Session时会把SessionID放入Cookies（浏览器允许Cookies）
- 重写URL,在地址栏加入SessionID（浏览器禁用Cookies）（SessionID可见，不安全）

#### 1.1.3 Session生命周期

- 创建：服务端调用HttpServletRequest.getSession(true)时才会创建Session
- 删除：设置超时时间/调用HttpSession.invalidate()

#### 1.1.4 SessionID的作用

- 用于重新获取服务器端的Session内容

#### 1.1.5 如何存储海量的Session

- 文件
- 数据库

#### 1.1.6 如何实现Session共享（服务器集群）

框架解决方案：

- asp.NET:可以修改Session存储机制为SQLServer，统一读取
- PHP支持把Session数据存储到memcache服务器
  - Memcache是一个高性能的分布式的内存对象缓存系统，通过在内存里维护一个统一的巨大的hash表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。简单的说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度。
- 或者直接拷贝

### 1.2 Servlet

#### 1.2.1 特点

- Servlet一般指所有实现了Servlet接口的类
- 主要用于处理客户端的HTTP请求并返回一个响应
- Servlet容器指提供了Servlet功能的服务器（如Tomcat）
- Servlet容器会将Servlet动态加载到服务器，通过HTTP请求和响应与客户端交互

#### 1.2.2 生命周期

- **init()** 初始化，只调用一次
- service() 执行实际任务，处理请求并返回响应
- destroy() 结束时调用，只调用一次，用于关闭数据库连接/释放资源等行为，调用后，Servlet对象被标记为垃圾回收，等待JVM垃圾回收器进行处理。

## 1.2 Spring

### 1.2.1 IOC

Inversion of Control 控制反转

#### 什么是控制反转？

控制反转就是把创建和管理Bean的任务转移给了第三方，而这个第三方，就是Spring IOC Container，对于IOC来说，最重要的就是容器。

容器负责创建、配置和管理Bean，它管理着bean的生命，控制着bean的依赖注入。

在项目中每次创建Bean是很麻烦的，所以我们使用IOC容器来托管，无需考虑其创建和销毁。

Bean事实上就是包装了的Object对象。

#### IOC容器

Spring使用ApplicationContext来构造容器，它是BeanFactory的子类，更好的补充和实现了BeanFactory。

BeanFactory简单粗暴，可以理解为HashMap：

- Key - bean name
- Value - bean object

但他一般只有get和put两个功能，所以又被称为”低级容器“。

ApplicationContext相比BeanFactory则多了很多功能，因为他继承了多个接口，也被称为“高级容器”。

![1](https://www.javadoop.com/blogimages/spring-context/1.png)

![2](https://www.javadoop.com/blogimages/spring-context/2.png)

ApplicationContext有三个具体实现子类（图1的绿字和红字），而从ApplicationContext再往上找，发现回到了BeanFactory。

#### 深入理解IOC

经典例子：Rectangle

- 两个变量：长和宽
- 两类方法：set()和toString()

```java
public class Rectangle {
    private int width;
    private int length;

    public Rectangle() {
        System.out.println("Hello World!");
    }


    public void setWidth(int widTth) {
        this.width = widTth;
    }

    public void setLength(int length) {
        this.length = length;
    }

    @Override
    public String toString() {
        return "Rectangle{" +
                "width=" + width +
                ", length=" + length +
                '}';
    }
}
```

然后在test类中为rectangle实例手动赋值：

```java
public class MyTest {
  @Test
  public void myTest() {
    Rectangle rect = new Rectangle();
    rect.setLength(2);
    rect.setWidth(3);
    System.out.println(rect);
  }
}
```

事实上，这就是IOC容器的做法，我们没有通过Rectangle类的有参构造方法来直接创建对象，而是把这个任务交由test类，由它来实现对对象的赋值（也就是创建），在这里，test事实上就是IOC容器。

#### 几个关键问题

**控制的是什么？**

控制即bean的创建，管理的权力；控制的是bean的整个生命周期。

**反转了什么？**

把对于bean的控制权从手里交到IOC容器手上，即反转。

#### 依赖注入

dependency injection

**本来我接受各种参数来构造一个对象，现在只接受一个参数——已经实例化的对象。**

解耦，免去复杂的读取构造对象配置的操作，无需考虑对象的创建和管理。

**依赖是什么？**

程序运行需要的外部资源。

**注入又是什么？**

配置文件把资源从外部注入到内部，容器加载了外部的文件，对象，数据，然后把这些资源注入给程序内部的对象，维护程序内外对象之间的依赖关系。

### 1.2.2 AOP

AOP即Aspect Oriented Programming，面向切面编程。

AOP能够让我们在不影响原有功能的前提下，为软件横向扩展功能。

#### 什么是横向扩展？

在WEB项目中，通常都遵守三层原则：

控制层（Controller）-》 业务层（Service）-》 数据层（DAO）

该结构即为纵向，而其中的某一层即为横向，AOP即作用于该横向模块中的每一个方法。

#### 为什么我们需要AOP？

总会有一些代码，会在所有的代码流程中都需要，如果每次都写一遍会使代码变得冗余。

例如：日志打印，权限控制，记录执行时间等。

#### AOP术语

Aspect（切面）：Aspect声明类似于Java中的类声明，在Aspect中包含一些Advice和Pointcut。

Join Point（连接点）：在程序中明确定义的点，包括方法调用，对类成员的访问，异常处理程序块的执行，也可以嵌套其他的Join Point。

Point Cut（切点）：表示一组Join Point通过逻辑关系/通配/正则表达式组合起来，定义了Advice即将要发生的地方。

Advice（通知）：定义程序点具体执行的操作，用before，after和around

Target（目标对象）：织入Advice的目标对象。

Weaving（织入）：将Aspect与其他对象连接起来，并创建Advice object的过程。

#### 通过AspectJ来理解AOP

**示例**

一个正常的逻辑类HelloWorld

```java
public class HelloWord {

    public void sayHello(){
        System.out.println("hello world !");
    }
    public static void main(String args[]){
        HelloWord helloWord =new HelloWord();
        helloWord.sayHello();
    }
}
```

编写AspectJ类

通知的定义包括五种：

- before 目标方法执行前执行，前置通知
- after 目标方法执行后执行，后置通知
- after returning 目标方法返回时执行 ，后置返回通知
- after throwing 目标方法抛出异常时执行 异常通知
- around 在目标函数执行中执行，可控制目标函数是否执行，环绕通知

```java
public aspect MyAspectJDemo {
    /**
     * 定义切点,日志记录切点
     */
    pointcut recordLog():call(* HelloWord.sayHello(..));

    /**
     * 定义切点,权限验证(实际开发中日志和权限一般会放在不同的切面中,这里仅为方便演示)
     */
    pointcut authCheck():call(* HelloWord.sayHello(..));

    /**
     * 定义前置通知!
     */
    before():authCheck(){
        System.out.println("sayHello方法执行前验证权限");
    }

    /**
     * 定义后置通知
     */
    after():recordLog(){
        System.out.println("sayHello方法执行后记录日志");
    }
}
```

运行结果

![img](https://pic2.zhimg.com/v2-b5f464a00d61cbfe863538cfb698c4b5_b.png)



AspectJ是一个java实现的AOP框架，能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能（需要特殊的编译器）

#### 代理

目标：拦截对真实业务对象的访问，实现调用者与实现者之间的解耦。

Java的代理模式分为两种：动态和静态。

静态代理在编译期间就已经确定被代理的对象，而动态代理则是在运行时，通过反射机制实现动态代理

两种代理从虚拟机加载类的角度来讲，本质上都是一样的，都是在原有类的行为基础上，加入其他行为/完全替换原有的行为。

##### 静态代理

静态代理采用的方式是我们手动的把方法换进去，需要代理对象和真实对象实现相同的接口。

```java
//接口
public interface Student {
    public void learn();
}

//真实对象A
public class StudentA implements Student {
    @Override
    public void learn() {
        System.out.println("好好学习，考上清北");
    }
}

//真实对象B
public class StudentB implements Student {
    @Override
    public void learn() {
        System.out.println("爷不学习，只爱农药");
    }
}

//静态代理对象：同样实现Student接口，可以在不修改目标对象的前提下扩展目标对象的功能。
public class StudentProxy implements Student {
    private Student student;

    public StudentProxy(Student student) {
        this.student = student;
    }

    @Override
    public void learn() {
        System.out.println("proxy start"); //扩展额外功能,如权限管理
        student.learn();
        System.out.println("proxy end");//扩展额外功能，如日志打印
    }
}

//客户端类：通过代理调用学生A和B的方法，代理角色需要持有真实角色的引用
public class StaticProxy {
    public static void main(String[] args) {
        Student studentA = new StudentA();
        StudentProxy proxy = new StudentProxy(studentA);
        proxy.learn();
        Student studentB = new StudentB();
        proxy = new StudentProxy(studentB);
        proxy.learn();
    }
}
```

优点：

- 解除客户端与实现类的耦合
- 在不更改目标对象的前提下扩展功能

缺点：

- 代理类和实现类实现了相同的接口，导致出现大量重复代码，接口每增加一个方法，就要同时维护真实对象和代理类，增加了代码维护复杂度。
- 代理对象只能服务于一种类型的对象，很明显在程序规模很大时静态代理无法胜任。

##### 动态代理

动态代理是一种方便运行时动态构建代理，动态处理代理方法的机制，分为两种：

###### 基于接口实现的Java Proxy（Java自带的）

```java
//接口类
interface Hello {
    void sayHello();
}

//真实对象实现类
class HelloImpl implements  Hello {
    @Override
    public void sayHello() {
        System.out.println("Hello World");
    }
}

//动态代理实现类
lass MyInvocationHandler implements InvocationHandler {
    private Object target;
    public MyInvocationHandler(Object target) {
        this.target = target;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
        System.out.println("Do something you like"); //扩展额外功能
        Object result = method.invoke(target, args);
        return result;
    }
}
```



###### 基于继承实现的cglib动态代理

































## 1.3 SpringMVC

## 1.4 MyBatis

### 1.4.1 为什么使用MyBatis？

![image-20201013202207348](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20201013202207348.png)

- 使用#{}配置XML文件更安全，使用${}配置有SQL注入风险

- Mybatis，Hibernate和JDBC

  - **Mybatis：**

  1. 入门简单，即学即用，提供了数据库查询的自动对象绑定功能，而且延续了很好的SQL使用经验，对于没有那么高的对象模型要求的项目来说，相当完美。

  2. 可以进行更为细致的SQL优化，可以减少查询字段。

  3. 缺点就是框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。

  4. 二级缓存机制不佳。

  - **Hibernate：**

  1. 功能强大，数据库无关性好，O/R映射能力强，如果你对Hibernate相当精通，而且对Hibernate进行了适当的封装，那么你的项目整个持久层代码会相当简单，需要写的代码很少，开发速度很快，非常爽。

  2. 有更好的二级缓存机制，可以使用第三方缓存。

  3. 缺点就是学习门槛不低，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡取得平衡，以及怎样用好Hibernate方面需要你的经验和能力都很强才行。

  - **JDBC：**
    - JDBC分为双层或三层架构，其中双层为C/S架构，即应用直接访问数据源，三层架构在于其引入了中间层（业务逻辑层），包括验证，计算，业务规则等。

### 1.4.2 MyBatis强大的动态SQL

- if标签

  ```xml
  <select>
      select * from user where
          <if test="username != null">
             username=#{username}
          </if>
          <if test="sex != null">
             and sex=#{sex}
          </if>
  </select>
  ```

  if标签往往用于判断参数是否为空，但如上所示，如果username输入为null，而会带来问题，查询语句会变成：

  ```sql
  select * from user where and sex = #{sex}
  ```

  很明显这是不符合语法的，我们需要使用where标签来解决这个问题

- where标签

  ```xml
  <select>
      select * from user
      <where>
          <if test="username != null">
             username=#{username}
          </if>
          <if test="username != null">
             and sex=#{sex}
          </if>
      </where>
  </select>
  ```

  where标签会根据标签内部是否有返回值来决定是否插入一个where，如果返回值以AND/OR开头，他会将其剔除

- set标签

  ```xml
  <!-- 根据 id 更新 user 表的数据 -->
  <update>
      update user u
          <set>
              <if test="username != null and username != ”">
                  u.username = #{username},
              </if>
              <if test="sex != null and sex != “">
                  u.sex = #{sex}
              </if>
          </set>
       where id=#{id}
  </update>
  ```

  set标签用于与if标签搭配的赋值语句

- choose（when，otherwise）标签

  ```xml
  <select>
        select * from user
        <where>
            <choose>
                <when test="id !='' and id != null">
                    id=#{id}
                </when>
                <when test="username !='' and username != null">
                    and username=#{username}
                </when>
                <otherwise>
                    and sex=#{sex}
                </otherwise>
            </choose>
        </where>
    </select>
  ```

  choose标签用于选择查询条件，when/otherwise类似于Java中的switch语句的case/default，只能多选一

- trim标签（可用于完成set/where标记）

  用trim改写where

  prefix：前缀

  prefixOverrides：去掉第一个and/or

  ```xml
  <select>
          select * from user
          <trim prefix="where" prefixOverrides="and | or">
              <if test="username != null">
                 and username=#{username}
              </if>
              <if test="sex != null">
                 and sex=#{sex}
              </if>
          </trim>
      </select>
  ```

  用trim改写set

  suffix：后缀

  suffixOverride：去掉最后一个标记（如逗号）

  ```xml
  <!-- 根据 id 更新 user 表的数据 -->
      <update id="updateUserById" parameterType="com.ys.po.User">
          update user u
              <trim prefix="set" suffixOverrides=",">
                  <if test="username != null and username !="">
                      u.username = #{username},
                  </if>
                  <if test="sex != null and sex != "">
                      u.sex = #{sex},
                  </if>
              </trim>
           where id=#{id}
      </update>
  ```

- SQL片段

  SQL片段的应用场景是条件语句的复用，例如我们经常需要根据用户名和性别来联合查询，那么我们就把这个代码抽取出来：

  ```xml
  <!-- 定义 sql 片段 -->
  <sql id="selectUserByUserNameAndSexSQL">
      <if test="username != null and username != ''">
          AND username = #{username}
      </if>
      <if test="sex != null and sex != ''">
          AND sex = #{sex}
      </if>
  </sql>
  ```

  注意※  sql片段往往**只包含条件**

  引用：

  ```xml
  <select>
      select * from user
      <trim prefix="where" prefixOverrides="and | or">
          <!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace -->
          <include refid="selectUserByUserNameAndSexSQL"></include>
          <!-- 在这里还可以引用其他的 sql 片段 -->
      </trim>
  </select>
  ```

- foreach标签

  foreach标签用于改写类似于：

  ```sql
  select * from user where id=1 or id=2 or id=3
  
  select * from user where id in (1,2,3)
  ```

  由于foreach需要一个能遍历的集合类，故创建VO类，封装一个List<Integer> ids属性：

  ```java
  public class UserVo {
      //封装多个用户的id
      private List<Integer> ids;
      public List<Integer> getIds() {
          return ids;
      }
      public void setIds(List<Integer> ids) {
          this.ids = ids;
      }
  }　
  ```

  用foreach标签来改写上述第一条sql语句：

  ```xml
  <select>
      select * from user
      <where>
          <!--
              collection:指定输入对象中的集合属性
              item:每次遍历生成的对象
              open:开始遍历时的拼接字符串
              close:结束时拼接的字符串
              separator:遍历对象之间需要拼接的字符串
              select * from user where 1=1 and (id=1 or id=2 or id=3)
            -->
          <foreach collection="ids" item="id" open="and (" close=")" separator="or">
              id=#{id}
          </foreach>
      </where>
  </select>
  ```

  用foreach标签来改写上述第二条sql语句：

  ```xml
  <select>
      select * from user
          <where>
              <!--
                  collection:指定输入对象中的集合属性
                  item:每次遍历生成的对象
                  open:开始遍历时的拼接字符串
                  close:结束时拼接的字符串
                  separator:遍历对象之间需要拼接的字符串
                  select * from user where 1=1 and id in (1,2,3)
                -->
              <foreach collection="ids" item="id" open="and id in (" close=") " separator=",">
                  #{id}
              </foreach>
          </where>
      </select>
  ```

### 1.4.3 MyBatis的延迟加载和缓存

#### 1.4.3.1 延迟加载

- 概念：

  延迟加载即懒加载，在多表查询时，并非所有的查询都要立刻进行。在查询带有账户信息的用户信息时，我们无需在加载用户信息时一同加载账户信息。这时我们就需要用到延迟加载，也就是用到数据时再加载。

- 优点：

  先从单表查询起，需要时再从关联表查询，大大提高数据库性能

- 缺点：

  大批量数据查询时，查询工作消耗时间过长，用户体验下降

- 使用场景

  一对多（班级学生），多对多（学生与选修课） 使用懒加载

  多对一（几乎没有），一对一（班长和班级） 使用立即加载

- [实现](https://blog.csdn.net/weixin_42364196/article/details/104941365)

#### 1.4.3.2 缓存

- 概念

  缓存即内存中存储的数据备份，当数据没发生本质改变时，我们直接从内存中读取，提高效率

- 使用

  适用于缓存机制的数据往往有以下特征：

  - 查询频率高且不经常变动
  - 正确与否对最终结果影响不大的数据

  不适用的数据则反之，如：商品库存，银行汇率，股市价格

- MyBatis的缓存机制

  MyBatis中的缓存根据缓存的生命周期可分为一级缓存和二级缓存，MyBatis默认开启一级缓存关闭二级缓存

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA4MzFyU1RneTFnY3h1bm1lZWkwajMwaDIwNmt0OTkuanBn?x-oss-process=image/format,png)

#### 1.4.3.3 MyBatis中的一级缓存

- 概念：

  一级缓存指的是Mybatis中SqlSession对象的缓存，当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供一块区域中。该区域的结构是一个Map。当我们再次查询同样的数据，Mybatis首先会去sqlsession中查询是否，如果该缓存中有这个数据，就直接从缓存中读取数据，否则就去数据库进行查询。当SqlSession对象消失(close)时，mybatis的一级缓存也就消失了。

- SqlSession

  当调用SqlSession的修改，添加，删除，commit()，close()等方法时，一级缓存会被清空（避免脏读）

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA4MzFyU1RneTFnY3h1cDkwaHd4ajMwaGgwOWdteW0uanBn?x-oss-process=image/format,png)

#### 1.4.3.4 MyBatis中的二级缓存

- 概念：

  二级缓存指SqlSessionFactory对象的缓存，由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。多个SqlSession去操作同一个Mapper映射的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。

- 特点：

  二级缓存中存放的对象的属性数据，而非对象数据。因此，即便从二级缓存读取数据，得到的对象也是不相同的。

![mybatis中的二级缓存](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA4MzFyU1RneTFnY3h4bGV5YzNkajMwZ3QwOGwzemYuanBn?x-oss-process=image/format,png)

**注意：当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这种就可以使用序列化方式来保存对象。**

## 1.5 Redis

### 1.5.1 Redis的数据类型

- String

  最简单也最常用的类型，仅使用get/se来完成KV缓存，如：微博粉丝数

- Hash

  hash结构类似map，可以将结构化的数据（比如一个对象）缓存在redis中（前提是没有嵌套其他对象），通过操作hash中的各个字段来实现读写缓存，如：用户信息

- List

  有序列表，可从左右插入，如消息队列

- Set

  - set是无序集合，自动去重
  - 为什么不使用hashset去重？
    - 需要对数据进行快去的全局去重，可以使用JVM内存中的HashSet，但这种情况对分布式系统不适用，对于分布式系统来说，只能基于redis进行全局的set去重
    - 可以基于set进行**交集，并集，差集**的操作，比如共同好友

- Sorted Set

  去重且可排序，写入时给一个分数，自动根据分数排序，如：列出前百名畅销商品

### 1.5.2 Redis的持久化 ⭐⭐⭐⭐

#### 1.5.2.1 RDB方式

- RDB持久化指在**指定的时间间隔内将内存中的数据集快照写入磁盘**。

- 过程：fork一个子进程，先将数据集写入临时文件，写入完成后，再替换之前的文件，用二进制压缩存储。

  - **fork()函数用于从一个已经存在的进程内创建一个新的进程，新的进程称为“子进程”，相应地称创建子进程的进程为“父进程”**。使用fork()函数得到的子进程是父进程的复制品，子进程完全复制了父进程的资源，包括进程上下文、代码区、数据区、堆区、栈区、内存信息、打开文件的文件描述符、信号处理函数、进程优先级、进程组号、当前工作目录、根目录、资源限制和控制终端等信息，而子进程与父进程的区别有进程号、资源使用情况和计时器等。

- RDB是Redis默认的持久化方式，会在对应目录下产生一个dump.rdb文件，重启会通过加载该文件以恢复数据。

  ![image-20201121094517824](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20201121094517824.png)

- 优点：

  - 只有一个文件**dump.rdb**，方便持久化
  - 性能最大化，**fork子进程来完成写操作**，主进程继续处理命令，即IO最大化，保证了redis的高性能
  - 数据集偏大时，RDB的启动效率会比AOF更高

- 缺点：

  - 数据安全性低（指定间隔时间进行持久化，若持久化之间redis故障会导致数据丢失），适用于对数据要求不严格时。
  - 由于RDB是通过fork子进程来完成持久化工作，因此当数据集较大时，可能会导致服务停止很久（几百毫秒甚至一秒）。

#### 1.5.2.2 AOF方式

- AOF持久化是**以日志形式记录服务器所处理的每一个写，删除操作，查询不会被记录**，以文本的方式记录，文件中可以看到详细的操作记录。

- AOF的出现是为了解决RDB的数据不一致，故其采用了以日志来记录操作并追加到文件中，Redis的重启会根据日志文件的内容完成数据恢复。

  ![image-20201121100237496](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20201121100237496.png)

- 优点：

  - 数据安全性，每次写入都会记录到日志
  - 数据一致性，redis宕机也不会导致数据不一致

- 缺点：

  - AOF文件占用内存比RDB更大；数据集打的时候，比RDB启动效率耕地更低。
  - 同步策略不同，运行效率比RDB更慢。

### 1.5.3 Redis单线程模型 ⭐

- 单线程指网络请求模块使用了一个线程（无需考虑并发安全性），该线程处理所有的网络请求，但Redis的其他模块仍使用了多个线程。
- Redis为什么这么快？
  - 绝大部分请求时纯粹的内存操作
  - 单线程，避免上下文切换和竞争条件
  - 非阻塞IO-IO多路复用

### 1.5.4 缓存穿透、缓存雪崩区别及解决方案⭐⭐⭐⭐

#### 1.5.4.1 缓存穿透

- 缓存穿透表示恶意用户模拟请求很多缓存中不存在的数据，由于缓存中都没有，这些请求会在短时间内直接访问数据库，导致数据库崩溃。
- 解决方案：布隆过滤器。布隆过滤器会判断key是否一定不存在，不存在则直接丢弃请求。
  - **布隆过滤器**（Bloom Filter）是由布隆在1970年提出的。它实际上是由一个很长的二进制向量和一系列随机映射函数组成，布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率（假正例False positives，即Bloom Filter报告某一元素存在于某集合中，但是实际上该元素并不在集合中）和删除困难，但是没有识别错误的情形（即假反例False negatives，如果某个元素确实没有在该集合中，那么Bloom Filter 是不会报告该元素存在于集合中的，所以不会漏报）。

#### 1.5.4.2 缓存雪崩

- 缓存集中在一段时间失效，发生大量的缓存穿透，所有查询落在数据库上，造成了缓存雪崩。
- 解决方案：
  - 分布均匀，不同的key设置不同的失效时间，让缓存失效的时间点尽量均匀
  - 限制流量：在缓存失效后，通过加锁或者队列来控制读数据库和写缓存的线程数量

### 1.5.5 主从复制 ⭐

- 问题的出现：

  持久化保证了即使 Redis 服务重启也不会丢失数据，因为 Redis 服务重启后会将硬盘上持久化的数据恢复到内存中，但是当 Redis 服务器的硬盘损坏了可能会导致数据丢失，不过通过Redis 的主从复制机制就可以避免这种单点故障，如下图：

  ![preview](https://pic2.zhimg.com/v2-e9e6d9d6cc59cd28823776ab27ae5f59_r.jpg)

  - 主Redis中的数据有两个副本，即使一台宕机另外两台也可以继续提供服务

  - 主Redis中的数据和从Redis上的数据保持实时同步，当主Redis写入时通过主从复制机制复制到两个副本。

  - 只有一个主Redis，可以有多个从Redis

  - 主从复制不会阻塞master，同步数据时，master可以继续处理client请求

  - Redis可以即是主又是从（级联结构）

    ![preview](https://pic3.zhimg.com/v2-540fd4c87e3821d5f97f18ca643b427e_r.jpg)

- 原理：

  - Redis的主从复制分为**全量同步**和**增量同步**。只有从机第一次连接上主机是全量同步，断线重连有可能触发全量同步也有可能是增量同步（master 判断 runid 是否一致），除此之外的情况都是增量同步。

    ![img](https://pic4.zhimg.com/80/v2-cc94828d6884eac1cc59ea312727307b_720w.jpg)

  - 全量同步

    （1）同步快照阶段：Master 创建并发送快照给 Slave，Slave 载入并解析快照。Master 同时将此阶段所产生的新的写命令存储到缓冲区。

    （2）同步写缓冲阶段：Master 向 Slave 同步存储在缓冲区的写操作命令。

    （3）同步增量阶段：Master 向 Slave 同步写操作命令。

    ![img](https://pic3.zhimg.com/80/v2-40e7dd00ad78ec9f3fd8c1cb36e32b26_720w.jpg)

  - 增量同步

    （1）Redis 增量同步主要指 **Slave 完成初始化后开始正常工作**时，**Master 发生的写操作同步到 Slave 的过程**。

    （2）通常情况下，Master 每执行一个写命令就会向 Slave 发送相同的**写命令**，然后 Slave接收并执行。

### 1.5.6 缓存淘汰策略

#### 1.5.6.1缓存过期策略

#### **主要从CPU使用和内存占用的角度来分析**

Redis同时使用了**惰性删除**和**定期删除**：

- 定时过期：为**每个设置了过期时间的key创建一个定时器**，到期则立即清除。
  - 优点：key过期时会第一时间被清除，内存会被及时释放。
  - 缺点：计时器会占用大量CPU资源来处理过期数据，影响缓存的响应时间和吞吐量。
- 惰性过期：只有**当访问一个key时才会判断它是否过期**，过期则清除。
  - 优点：最大化节省CPU资源（无计时器）。
  - 缺点：可能存在大量过期key未清除，内存被大量占用。
- 定期过期：每隔一定时间，会扫描一定数量的Redis中expires字典中一定数量的key，并清除其中过期的key
  - expires字典：该字典的key为某个缓存数据的指针，value为毫秒精度表示过期时间的UNIX时间戳。
  - 定期过期策略是前两者的折中方案，可以在不同情况下达到CPU和内存资源的最优平衡效果。

#### 1.5.6.2 内存淘汰策略

当内存不足时，怎么处理新写入？

- noeviction：新写入报错
- allkey-lru：移除最近最少使用的key
- allkeys-random：随机移除key
- volatile-lru：在设置了过期时间的键空间中，移除最近最少使用的key
- volatile-random：在设置了过期时间的键空间中，随机移除key
- volatile-ttl：移除过期时间最早的key

### 1.5.7 String数据类型实现原理

String类型是由**SDS（Simple Dynamic String）**实现的。Redis并没有采用C语言的字符串来表示，而是自己构建了一种名为SDS的抽象类型，Redis使用SDS作为其默认字符串表示。

**注意：SDS除了⽤于实现字符串类型，还被⽤作AOF持久化时的缓冲区。**

相比于C语言中的String，SDS有以下几个优点，这些优点也是Redis高效的原因：

首先我们要知道，C语言中的String底层使用N+1的字符数组来表示长度为N的字符串，这就带来了弊端：

1. **获取长度的时间复杂度更低**

   获取C字符串的长度，我们需要遍历整个字符串数组，时间复杂度为O(n)；而SDS使用变量len保存字符串长度，O(1)即可获取。

2. **杜绝缓冲区溢出**

   C字符串易导致缓冲区溢出，假设程序里有两个在内存中紧邻的字符串s1和s2，s1的值为Redis，底层数组的值为['R','e','d','i','s','\0']，s2的值为Memcache，底层数组的值为['M','e','m','c','a','c','h','e','\0']，在C语言中如果要执行strcat(s1, " cluster")把s1修改为Redis cluster，如果忘记在执行strcat命令之前为s1重新分配空间，那么在执行完strcat命令之后，s1底层数组的值变为['R','e','d','i','s',' ','c','l','u','s','t','e','r','\0']，s2底层数组的值变为['c','l','u','s','t','e','r','\0','\0']，s1的数据溢出到s2所在的内存空间，s2的值被意外修改。与C语言不同，当SDS API需要对SDS进行修改时，API会先检查SDS当前剩余空间是否满足修改之后所需的空间，如果不满足的话API会自动将SDS的空间扩展至修改之后所需空间大小，然后再执行实际的修改操作，所以SDS不会出现缓冲区溢出问题。

3. **减少修改字符串时带来的内存重分配次数**

   C字符串的每次增长或缩短都涉及到内存的重分配操作：

   - 增长需要分配新的额外空间否则会造成缓冲区溢出
   - 缩短需要释放内存否则会造成内存泄漏

   由于内存的重分配操作复杂，非常耗时，故不适用于Redis

   SDS通过**空间预分配**来解决C字符串遇到的增长问题，当SDS的长度小于1M时，每次分配等同len的空间（2*len+1）；当SDS长度大于1M时，每次只扩展1M（len+1M+1）（字符串长度最大为512M）。

   SDS通过**惰性空间释放**，避免了缩短字符串时所需的内存重分配操作，并为将来由可能的增长操作提供了优化。当字符串收缩时，程序不会立即执行内存重分配来回收收缩后内存多出来的空间，而是使用free属性记录下来，以备将来使用。

4. **二进制安全**

   C字符串中除了字符串末尾外不能包含空字符（‘\0’），否则最先被读入的空字符将被认为是字符串结尾，这限制使得C字符串只能保存文本数据，而图片，音频，视频，压缩文件这样的二进制数据都无法保存。

   SDS通过len属性来判断字符串是否结束，也可以兼容部分C字符串函数。

### 1.5.8 哨兵机制

#### 1.5.8.1 哨兵sentinel的意义

Redis和MySQL一样可以使用主从备份模式。

**主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。**这不是一种推荐的方式，更多时候，我们优先考虑**哨兵模式**。

哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是**哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。**

![img](https:////upload-images.jianshu.io/upload_images/11320039-57a77ca2757d0924.png?imageMogr2/auto-orient/strip|imageView2/2/w/507/format/webp)

Redis哨兵

这里的哨兵有两个作用

- 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。
- 当哨兵监测到master宕机，会自动将slave切换成master，然后通过**发布订阅模式**通知其他的从服务器，修改配置文件，让它们切换主机。

#### 1.5.8.2 多哨兵模式

然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。

用文字描述一下**故障切换（failover）**的过程。假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为**主观下线**。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为**客观下线**。这样对于客户端而言，一切都是透明的。

### 1.5.9 分布式锁

#### 1.5.9.1 使用场景

分布式锁是控制分布式系统或不同系统之间共同访问共享资源的⼀种锁实现，如果不同的系统或同⼀个 系统的不同主机之间共享了某个资源时，往往需要互斥来防⽌彼此⼲扰来保证⼀致性。

#### 1.5.9.2 条件

1. 互斥性：在任意一个时刻，只有一个客户端持有锁。
2. 无死锁：即便持有锁的客户端崩溃或者其他意外事件，锁仍然可以被获取。
3. 容错：只要大部分Redis节点都活着，客户端就可以获取和释放锁

#### 1.5.9.3 实现

1. 数据库
2. Memcached（add命令）
3. Redis（setnx命令）
4. Zookeeper（临时节点）

### 1.5.10 List数据类型实现原理

Redis对外暴露的上层list数据类型，经常被用作队列使用。比如它支持的如下一些操作：

- `lpush`: 在左侧（即列表头部）插入数据。
- `rpop`: 在右侧（即列表尾部）删除数据。
- `rpush`: 在右侧（即列表尾部）插入数据。
- `lpop`: 在左侧（即列表头部）删除数据。

这些操作都是O(1)时间复杂度的。

当然，list也支持在任意中间位置的存取操作，比如`lindex`和`linsert`，但它们都需要对list进行遍历，所以时间复杂度较高，为O(N)。

概括起来，list具有这样的一些特点：它是一个能维持数据项先后顺序的列表（各个数据项的先后顺序由插入位置决定），便于在表的两端追加和删除数据，而对于中间位置的存取具有O(N)的时间复杂度。这不正是一个双向链表所具有的特点吗？

list的内部实现quicklist正是一个双向链表。在quicklist.c的文件头部注释中，是这样描述quicklist的：

> A doubly linked list of ziplists

它确实是一个双向链表，而且是一个ziplist的双向链表。

这是什么意思呢？

我们知道，双向链表是由多个节点（Node）组成的。这个描述的意思是：quicklist的每个节点都是一个ziplist。

ziplist本身也是一个能维持数据项先后顺序的列表（按插入位置），而且是一个内存紧缩的列表（各个数据项在内存上前后相邻）。比如，一个包含3个节点的quicklist，如果每个节点的ziplist又包含4个数据项，那么对外表现上，这个list就总共包含12个数据项。

quicklist的结构为什么这样设计呢？总结起来，大概又是一个空间和时间的折中：

- 双向链表便于在表的两端进行push和pop操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。
- ziplist由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的realloc。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。

于是，结合了双向链表和ziplist的优点，quicklist就应运而生了。

不过，这也带来了一个新问题：到底一个quicklist节点包含多长的ziplist合适呢？比如，同样是存储12个数据项，既可以是一个quicklist包含3个节点，而每个节点的ziplist又包含4个数据项，也可以是一个quicklist包含6个节点，而每个节点的ziplist又包含2个数据项。

这又是一个需要找平衡点的难题。我们只从存储效率上分析一下：

- 每个quicklist节点上的ziplist越短，则内存碎片越多。内存碎片多了，有可能在内存中产生很多无法被利用的小碎片，从而降低存储效率。这种情况的极端是每个quicklist节点上的ziplist只包含一个数据项，这就蜕化成一个普通的双向链表了。
- 每个quicklist节点上的ziplist越长，则为ziplist分配大块连续内存空间的难度就越大。有可能出现内存里有很多小块的空闲空间（它们加起来很多），但却找不到一块足够大的空闲空间分配给ziplist的情况。这同样会降低存储效率。这种情况的极端是整个quicklist只有一个节点，所有的数据项都分配在这仅有的一个节点的ziplist里面。这其实蜕化成一个ziplist了。

可见，一个quicklist节点上的ziplist要保持一个合理的长度。那到底多长合理呢？这可能取决于具体应用场景。实际上，Redis提供了一个配置参数`list-max-ziplist-size`，就是为了让使用者可以来根据自己的情况进行调整。

```
list-max-ziplist-size -2
```

我们来详细解释一下这个参数的含义。它可以取正值，也可以取负值。

当取正值的时候，表示按照数据项个数来限定每个quicklist节点上的ziplist长度。比如，当这个参数配置成5的时候，表示每个quicklist节点的ziplist最多包含5个数据项。

当取负值的时候，表示按照占用字节数来限定每个quicklist节点上的ziplist长度。这时，它只能取-1到-5这五个值，每个值含义如下：

- -5: 每个quicklist节点上的ziplist大小不能超过64 Kb。（注：1kb => 1024 bytes）
- -4: 每个quicklist节点上的ziplist大小不能超过32 Kb。
- -3: 每个quicklist节点上的ziplist大小不能超过16 Kb。
- -2: 每个quicklist节点上的ziplist大小不能超过8 Kb。（-2是Redis给出的默认值）
- -1: 每个quicklist节点上的ziplist大小不能超过4 Kb。

另外，list的设计目标是能够用来存储很长的数据列表的。

当列表很长的时候，最容易被访问的很可能是两端的数据，中间的数据被访问的频率比较低（访问起来性能也很低）。如果应用场景符合这个特点，那么list还提供了一个选项，能够把中间的数据节点进行压缩，从而进一步节省内存空间。Redis的配置参数`list-compress-depth`就是用来完成这个设置的。

```
list-compress-depth 0
```

这个参数表示一个quicklist两端不被压缩的节点个数。注：这里的节点个数是指quicklist双向链表的节点个数，而不是指ziplist里面的数据项个数。实际上，一个quicklist节点上的ziplist，如果被压缩，就是整体被压缩的。

参数`list-compress-depth`的取值含义如下：

- 0: 是个特殊值，表示都不压缩。这是Redis的默认值。
- 1: 表示quicklist两端各有1个节点不压缩，中间的节点压缩。
- 2: 表示quicklist两端各有2个节点不压缩，中间的节点压缩。
- 3: 表示quicklist两端各有3个节点不压缩，中间的节点压缩。
- 依此类推…

由于0是个特殊值，很容易看出quicklist的头节点和尾节点总是不被压缩的，以便于在表的两端进行快速存取。

Redis对于quicklist内部节点的压缩算法，采用的[LZF](http://oldhome.schmorp.de/marc/liblzf.html)——一种无损压缩算法。

### 1.5.11 Redis应用场景

- 热点数据的缓存

- 限时业务：手机验证码，限时优惠等。

- 计数器相关问题：redis可以实现原子性的递增，基于此特性，Redis可以用于高并发秒杀活动，分布式序列号生成如：手机号短信数量限制，接口特定时间间隔内请求数量限制等。

- 排行榜问题：关系型数据库在排行榜查询方面普遍表现不佳，可使用Redis提供的SortedSet进行热点数据的排序。

- 分布式锁：锁的实现主要基于redis的SETNX命令

  - SETNX key value

    将key值设为value，当且仅当key不存在。

    若key存在，则不做任何动作。

    SETNX = SET IF NOT EXIST

    成功返回1

    失败返回0

  - SETNX实现同步锁流程：

    1. 使用SETNX获取锁
    2. 为避免死锁，设置失效时间
    3. 释放锁，使用DEL命令将锁数据删除



## 1.6 RabbitMQ

### 1.6.1 使用RabbitMQ的原因 ⭐⭐⭐

- 同步和异步：**定义：同步和异步关注的是*\*消息通信机制\**(synchronous communication/ asynchronous communication)。同步，就是调用某个东西是，调用方得等待这个调用返回结果才能继续往后执行。异步，和同步相反 调用方不会立即得到结果，而是在调用发出后调用者可用继续执行后续操作，被调用者通过状态来通知调用者，或者通过回调函数/通知来处理这个调用。**如果使用状态来通知，那么调用者就需要每隔一定时间检查一次，效率很低；回调函数和通知的效率则要高得多，因为调用者几乎不需要执行额外的操作。

- [消息队列（MQ）是什么](https://www.zhihu.com/question/54152397?sort=created)

- 消息队列是一种中间件，将要传输的数据放到队列中（放入为生产者，取出为消费者）


- 应用场景：

  - 解耦，相互依赖的系统不再依赖，由生产者将产生的请求/数据放入消息队列，消费者自由决定是否要取和何时取。
  - 异步：可以通过消息队列来实现异步通信的系统。
  - 削峰/限流：消费者根据自己的能力选择从消费队列中拿去数据，由消费者自己控制，可以达到削峰的效果。

- 问题：

  - 高可用？

    消息队列的三种应用场景决定了它一定是集群/分布式的中间件，故我们无法使用JDK中已经实现好的内存队列。

  - 系统复杂性

    - 重复消费

      使用幂等操作来解决重复消费的问题，

    - 消息丢失

    - 顺序消费

  - 数据一致性

    使用分布式事务，将所有业务放在同一个事务中，要么成功，要么回滚。

  ![image-20201125170818613](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20201125170818613.png)

  

  





























# Java线程

## synchronized（重量级锁）：

作用：

保证同一时刻只有一个线程执行被修饰的方法/代码。

场景：

**保证线程安全，解决多线程中的并发同步问题（实现的是阻塞型并发）**，具体场景如下：

1. 修饰 实例方法 / 代码块时，（同步）保护的是同一个对象方法的调用 & 当前实例对象
2. 修饰 静态方法 / 代码块时，（同步）保护的是 静态方法的调用 & class 类对象

原理：

1. 依赖 `JVM` 实现同步
2. 底层通过一个监视器对象`（monitor）`完成， `wait（）`、`notify（）` 等方法也依赖于 monitor 对象

> 监视器锁（monitor）的本质 依赖于 底层操作系统的互斥锁（Mutex Lock）实现



# 设计模式（23种）

为了让面向对象保持良好结构的秘诀。

![image-20200913213659649](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200913213659649.png)

## 1.构建型模式（用于构建对象）

- ### 工厂方法模式

  简单工厂：将对象构建时的细节封装在生产新实例的工厂之中。降低耦合，减少代码重复。

  工厂方法：让每一个对象有一个单独的工厂（避免产生超级类，遵循单一职责原则和开闭原则）。

- ### 抽象工厂模式

  提取出工厂接口，调用者只需将各个工厂统一作为接口对象使用

  ![image-20200913213946797](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200913213946797.png)

  ![image-20200913214018591](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200913214018591.png)

- ### 单例模式

  适用于全局只需要一个实例的对象，避免对象重复创建以及操作不同实例产生的逻辑错误。

  - 饿汉式：声明时初始化

    占用内存，增加类初始化时间

    **使用与构建不复杂且会立即使用的单例对象**

    QQ，微信等即时通讯软件

  - 懒汉式：调用时初始化

    避免内存浪费，减少类初始化时间

    **构建耗时长，不一定用得到的单例对象**

    非线程安全

    双检锁实现的线程安全的单例模式：

    ![image-20200913214542648](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200913214542648.png)

    静态内部类保证线程安全：

    ![image-20200913214639350](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200913214639350.png)

    ![image-20200913214714370](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200913214714370.png)

- ### 建造型模式

  适用于创建过程稳定但配置多变的对象。

  ![image-20200913215035739](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200913215035739.png)

  ![image-20200913215047071](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200913215047071.png)

  ![image-20200913215107255](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200913215107255.png)

  通过Builder构造方法传入必须配置的属性，通过Builder的链式调用方法传入可选属性，不配置则使用默认配置。

  构建过程稳定，无需担心忘记配置。

- ### 原型模式

  用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

  Java Object.clone()即为原型模式。

  Java提供了语法糖,即实现Cloneable接口

![image-20200913215619567](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200913215619567.png)

## 2.结构型模式

用于设计程序结构

- ### 适配器模式（Adapter）

  适用于有相关性但不兼容的结构，将不兼容的接口转化为可协作的接口。

  ![image-20200914141630254](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200914141630254.png)

- ### 桥接模式

  将抽象部分与实现部分分离，使其可以各自独立变化

  主要用于两个或多个同等级的接口

  例如几何图形的形状和颜色

- ### 组合模式

  非组合模式的弊端：

  - 相似的对象会导致产生荣冗余的字段
  - 无法将相似的对象统一对待（例如树的叶子和树枝）

  ![image-20200914142714358](C:\Users\90707\Desktop\image-20200914142714358.png)

  ![image-20200914151237151](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200914151237151.png)

  相似的对象均继承该抽象类，这样就解决了两个弊端

  但这样又会出现新的问题，这样违背了接口隔离原则：

  ![image-20200914151955442](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200914151955442.png)

  ![image-20200914152030500](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200914152030500.png)

  安全方式遵循了接口隔离原则，却也带来了不便：

  ![image-20200914152150473](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200914152150473.png)

- ### 装饰模式

  不会改变原有的类

  - 增强一个类的原有功能
  - 为一个类新增功能

  ![image-20200914152848772](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200914152848772.png)

  ![image-20200914153330280](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200914153330280.png)

  ![image-20200914153343220](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200914153343220.png)

  ![image-20200914162106819](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200914162106819.png)

- ### 外观模式

  即封装

  ![image-20200914162314503](C:\Users\90707\AppData\Roaming\Typora\typora-user-images\image-20200914162314503.png)

  

- ### 享元模式

  程序可复用即共享对象，有些对象本身不一样，但通过一点点变化就可以复用通过，如超级玛丽（40kb）。

- ### 代理模式

  静态代理/动态代理

  多用于打印日志/权限管理

  加以控制类的行为

  动态代理可以节省冗余的代码量

## 3.行为型模式（类之间的交互与协作）

- ### 责任链模式

  责任链主要用于处理**职责相同，程度不同的类**。

  其主要优点有：

  - 降低了对象之间的耦合度。在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了。
  - 扩展性强，满足开闭原则。可以根据需要增加新的请求处理类。
  - 灵活性强。可以动态地改变链内的成员或者改变链的次序来适应流程的变化。
  - 简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的条件判断语句。
  - 责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。不再需要 “项目经理” 来处理所有的责任分配任务。

  但我们在使用中也发现了它的一个明显缺点，如果这个 bug 没人处理，可能导致 “程序员祭天” 异常。其主要缺点有：

  - 不能保证每个请求一定被处理，该请求可能一直传到链的末端都得不到处理。
  - 如果责任链过长，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。
  - 责任链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于责任链拼接次序错误而导致系统出错，比如可能出现循环调用。