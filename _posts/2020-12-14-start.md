---
title: 开始！
author: yousabla
date: 2020-12-14 18:18:00 +0800
categories: [Algorithm]
tags: [Algorithm]
pin: true
---

## 第一篇！

废话：

拖拖拖！老拖延症了，今天又是颓废的一天，在床上躺到了四点，毕设导师都开始催了，感觉再这么混下去别说找工作了，毕业都费劲儿，起来干活吧！

之前也做过个博客，自己用SpringBoot搭的，可惜，没备份，项目文件全丢了，后来想想有个博客督促自己学习还是挺好的，就用github重新搭了个，打算在上面记录分享以下自己的学习情况，不废话了，直接开始。

今儿做了道挺有意思的题，先看题：

------

**LeetCode-649.Dota2 参议院**

Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)

Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：



**禁止一名参议员的权利：**

参议员可以让另一位参议员在**这一轮和随后的几轮中丧失所有的权利。**

**宣布胜利：**

如果参议员发现有权利投票的参议员都是**同一个阵营**的，他可以宣布胜利并决定在游戏中的有关变化。

 


给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。

以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。

假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 Radiant 或 Dire。

 

示例 1：

```
输入："RD"
输出："Radiant"
解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人
```


示例 2：

```
输入："RDD"
输出："Dire"
解释：
第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利
第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止
第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利
因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利
```


提示：

给定字符串的长度在 [1, 10,000] 之间。

------

我第一个反应是计数？看了看示例，立刻否决了这个想法（仔细审题！）。

再看参议员的权力，可以否决另一位参议员此轮和之后轮次的所有权利，也就是谁先说话谁nb（恶人先告状）。

所以我们发现了核心问题：次序很重要，先说话的人有决定权，后说话的人可能没机会说话。

那我们该怎么模拟这个投票过程呢？怎样来表示次序呢？

------

想到了Mysql中的隔离级别：Repeatable Read，可重复读。

复习一下：

Mysql通过MVCC来实现RR的隔离级别。

MVCC即Multi-Version Concurrency Control，多版本并发控制：

每个连接到数据库的读线程，在某个瞬间看到的只是数据库一个快照，写操作未提交前是不可见的。

当MVCC数据库需要更新数据时，他不会直接覆盖旧数据，而是将旧数据标记为过时，在别处新增数据，这样就会存储多个版本的数据，但只有一个版本的数据是最新的。

这种方式允许读线程读取旧版本数据，即使在读的过程中数据被修改/删除了也不影响。

这种多版本控制的方式避免的填充删除操作在内存和磁盘造成的空洞开销，但需要周期性整理已删除过时数据。

Mysql是如何实现MVCC的呢？

InnoDB在每行记录后保存两个隐藏的字段：创建时间和删除时间。

这两个字段存储的并不是实际时间，而是系统版本号，当数据被修改时，版本号+1.

在读取事务开始前，系统会给当前读事务一个版本号，事务只会读取版本号 <= 当前版本号的数据。

若此时其他事务修改了该数据，则其版本号+1，读事务就读不到更新后的数据了。

------

这波是强行复习，不过思想是一致的，我们也可以用时间戳来解决这个问题。

```java
class Solution {
    public String predictPartyVictory(String senate) {
        int n = senate.length();
        //用两个队列来模拟两个党派
        Queue<Integer> radiant = new LinkedList<>();
        Queue<Integer> dire = new LinkedList<>();
        //给予时间戳
        for (int i = 0; i < n; i++) {
            if (senate.charAt(i) == 'R'){
                radiant.add(i);
            }else{
                dire.add(i);
            }
        }
        //行使权力，哪方有发言权就下一轮继续发言
        while(!radiant.isEmpty() && !dire.isEmpty()){
            int d = dire.poll(),r = radiant.poll();
            if (r < d){
                radiant.add(r + n);
            }else{
                dire.add(d + n);
            }
        }
        return radiant.isEmpty()? "Dire":"Radiant";
    }
}
```

这道题算是很新颖的体型，不同于常见的套路题，题本身和解法都很有意思，分享给自己。

















